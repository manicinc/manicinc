// src/components/Blog/BlogVines.tsx
import React, { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import styles from './BlogVines.module.css';

// --- Configuration ---
const NUM_MAIN_VINES = 8;
const MAX_BRANCH_DEPTH = 4;
const BRANCH_PROBABILITY = 0.38;
const SEGMENTS_PER_VINE = 10;
const SPREAD_FACTOR = 65;
const CURVE_FACTOR = 0.75;
const IDLE_TIMEOUT_MS = 3500;
const INTERACTION_TIMEOUT_MS = 350;
const FAST_SCROLL_THRESHOLD = 120;
const RESIZE_DEBOUNCE_MS = 250;
const SCROLL_UPDATE_INTERVAL_MS = 50;
// --- New: Flower Configuration ---
const FLOWER_PROBABILITY = 0.15; // Chance (0-1) of a flower appearing at a segment end
const FLOWER_BASE_RADIUS = 2.5; // Base size of the flower circle
const FLOWER_ALT_COLOR_THRESHOLD = 0.9; // Random value > this threshold triggers alt color

// Type for activity state
type ActivityStateType =
  | 'idle' | 'active' | 'scrolling-fast' | 'interacting' | 'typing' | 'window-inactive';

// Type for vine path data
interface VinePathData {
    pathD: string;
    strokeVar: number;
    delay: string;
}

// --- New: Type for flower data ---
interface FlowerData {
    cx: number;
    cy: number;
    r: number;
    colorVar: number; // Random value (0-1) for potential color variation
    delay: string; // Animation delay
}

// --- Helper: Generate Organic Path & Flowers ---
// Updated to return both VinePathData and FlowerData[]
const generateVinePath = (
    startX: number, startY: number,
    targetX: number, targetY: number,
    segments: number,
    spread: number,
    curveFactor: number,
    branchProbability: number,
    maxBranchDepth: number,
    baseIndex: number,
    currentDepth: number = 0
): { mainPath: VinePathData; branches: VinePathData[]; flowers: FlowerData[] } => {
    let pathD = `M${startX.toFixed(1)} ${startY.toFixed(1)}`;
    let branches: VinePathData[] = [];
    let flowers: FlowerData[] = []; // Array to hold flowers generated by this path/branch
    let currentX = startX;
    let currentY = startY;
    const totalDX = targetX - startX;
    const totalDY = targetY - startY;

    for (let i = 1; i <= segments; i++) {
        const progress = i / segments;
        const segmentEndX = startX + totalDX * progress + (Math.random() - 0.5) * 8;
        const segmentEndY = startY + totalDY * progress + (Math.random() - 0.5) * 8;

        const segmentDX = segmentEndX - currentX;
        const segmentDY = segmentEndY - currentY;
        const segmentLength = Math.sqrt(segmentDX * segmentDX + segmentDY * segmentDY) || 1;
        const perpDX = -segmentDY / segmentLength;
        const perpDY = segmentDX / segmentLength;

        const randomOffset1 = (Math.random() - 0.5) * spread * curveFactor * (progress + 0.1);
        const controlX1 = currentX + segmentDX * 0.35 + perpDX * randomOffset1;
        const controlY1 = currentY + segmentDY * 0.35 + perpDY * randomOffset1;
        const randomOffset2 = (Math.random() - 0.5) * spread * curveFactor * (1.1 - progress);
        const controlX2 = segmentEndX - segmentDX * 0.3 + perpDX * randomOffset2;
        const controlY2 = segmentEndY - segmentDY * 0.3 + perpDY * randomOffset2;

        pathD += ` C ${controlX1.toFixed(1)} ${controlY1.toFixed(1)}, ${controlX2.toFixed(1)} ${controlY2.toFixed(1)}, ${segmentEndX.toFixed(1)} ${segmentEndY.toFixed(1)}`;

        // --- Flower Generation Logic ---
        // Add a flower at segment end based on probability (and not too close to start)
        if (i > 1 && Math.random() < FLOWER_PROBABILITY) {
            const flowerDelay = (baseIndex * 0.1 + i * 0.05 + Math.random() * 0.3).toFixed(2) + 's';
            flowers.push({
                cx: segmentEndX,
                cy: segmentEndY,
                r: FLOWER_BASE_RADIUS * (0.8 + Math.random() * 0.4), // Slight size variation
                colorVar: Math.random(), // For potential color change
                delay: flowerDelay,
            });
        }

        // --- Branching Logic ---
        if (currentDepth < maxBranchDepth && Math.random() < branchProbability && i < segments && i > 1) {
            const branchAngle = (Math.random() - 0.5) * Math.PI / 1.4;
            const branchLengthFactor = 0.3 + Math.random() * 0.5;
            const branchLength = segmentLength * branchLengthFactor;
            const branchTargetX = segmentEndX + Math.cos(branchAngle) * perpDX * branchLength - Math.sin(branchAngle) * perpDY * branchLength;
            const branchTargetY = segmentEndY + Math.sin(branchAngle) * perpDX * branchLength + Math.cos(branchAngle) * perpDY * branchLength;

            const branchResult = generateVinePath(
                segmentEndX, segmentEndY, branchTargetX, branchTargetY,
                Math.max(3, segments - 2), spread * 0.5, curveFactor * 0.9,
                branchProbability * 0.5, maxBranchDepth,
                baseIndex + branches.length + flowers.length + 1, // Update base index for unique delays
                currentDepth + 1
            );
            branches.push(branchResult.mainPath);
            branches.push(...branchResult.branches);
            flowers.push(...branchResult.flowers); // Collect flowers from branches
        }

        currentX = segmentEndX;
        currentY = segmentEndY;
    }

    // Generate random values for the main path segment
    const strokeVar = Math.random();
    const pathDelay = (baseIndex * 0.15 + Math.random() * 0.4).toFixed(2) + 's';

    return {
        mainPath: { pathD, strokeVar, delay: pathDelay },
        branches,
        flowers // Return collected flowers
    };
};

// --- Component ---
const BlogVines: React.FC = () => {
    const svgRef = useRef<SVGSVGElement>(null);
    const [allPaths, setAllPaths] = useState<VinePathData[]>([]);
    // --- New: State for flowers ---
    const [allFlowers, setAllFlowers] = useState<FlowerData[]>([]);
    const [activityState, setActivityState] = useState<ActivityStateType>('idle');
    const [currentDimensions, setCurrentDimensions] = useState({ width: 0, height: 0 });

    // Refs
    const idleTimerRef = useRef<NodeJS.Timeout | null>(null);
    const interactionTimerRef = useRef<NodeJS.Timeout | null>(null);
    const scrollStateRef = useRef({ lastY: 0, lastTime: 0, isScrollingFast: false });
    const activityStateRef = useRef<ActivityStateType>(activityState);

    useEffect(() => {
        activityStateRef.current = activityState;
    }, [activityState]);

    // --- Path & Flower Generation Logic ---
    // Updated to generate and set both paths and flowers
    const generateAllPathsAndFlowers = useCallback((): void => {
        if (!svgRef.current || currentDimensions.width === 0 || currentDimensions.height === 0) {
            console.log("Skipping generation: No SVG ref or zero dimensions.");
            setAllPaths([]);
            setAllFlowers([]);
            return;
        }
        const { width, height } = currentDimensions;
        const navHeightEstimate = 60;
        console.log(`Generating paths/flowers for dimensions: ${width}x${height}`);

        const generatedPaths: VinePathData[] = [];
        const generatedFlowers: FlowerData[] = []; // Temp array for flowers
        const origins: { sx: number, sy: number, tx: number, ty: number }[] = [];

        // Define origin points (same as before)
        for (let i = 0; i < NUM_MAIN_VINES; i++) {
            const side = i % 4;
            let sx, sy, tx, ty;
            const jitter = 30;
            switch (side) {
                case 0: sx = Math.random() * width; sy = navHeightEstimate - Math.random() * jitter; tx = sx + (Math.random() - 0.5) * width * 0.7; ty = height * 0.3 + Math.random() * height * 0.5; break;
                case 1: sx = width + Math.random() * jitter - jitter / 2; sy = navHeightEstimate + Math.random() * (height - navHeightEstimate); tx = width * 0.7 - Math.random() * width * 0.6; ty = sy + (Math.random() - 0.5) * height * 0.5; break;
                case 2: if (Math.random() > 0.5) { sx = Math.random() * width; sy = height + Math.random() * jitter - jitter / 2; tx = sx + (Math.random() - 0.5) * width * 0.7; ty = height * 0.7 - Math.random() * height * 0.5; } else continue; break;
                case 3: default: sx = Math.random() * jitter - jitter / 2; sy = navHeightEstimate + Math.random() * (height - navHeightEstimate); tx = width * 0.3 + Math.random() * width * 0.6; ty = sy + (Math.random() - 0.5) * height * 0.5; break;
            }
             tx = Math.max(jitter, Math.min(width - jitter, tx));
             ty = Math.max(navHeightEstimate + jitter / 2, Math.min(height - jitter, ty));
            origins.push({ sx, sy, tx, ty });
        }

        // Generate main vines, branches, and flowers
        origins.forEach(({ sx, sy, tx, ty }, index) => {
            const result = generateVinePath(
                sx, sy, tx, ty,
                SEGMENTS_PER_VINE, SPREAD_FACTOR, CURVE_FACTOR,
                BRANCH_PROBABILITY, MAX_BRANCH_DEPTH,
                index * (MAX_BRANCH_DEPTH + 1) * SEGMENTS_PER_VINE // Base index for delay calculation
            );
            generatedPaths.push(result.mainPath);
            generatedPaths.push(...result.branches);
            generatedFlowers.push(...result.flowers); // Collect flowers
        });

        console.log(`Generated ${generatedPaths.length} paths and ${generatedFlowers.length} flowers.`);
        setAllPaths(generatedPaths);
        setAllFlowers(generatedFlowers); // Set the flower state
    }, [currentDimensions]); // Regenerate if dimensions change

    // --- Effect to Update Dimensions ---
    useEffect(() => {
        let debounceTimer: NodeJS.Timeout;
        const updateDimensions = () => {
             if (svgRef.current) {
                const parentRect = svgRef.current.parentElement?.getBoundingClientRect();
                const newWidth = parentRect?.width ?? window.innerWidth;
                const newHeight = parentRect?.height ?? window.innerHeight;
                if (Math.abs(newWidth - currentDimensions.width) > 1 || Math.abs(newHeight - currentDimensions.height) > 1) {
                    setCurrentDimensions({ width: newWidth, height: newHeight });
                }
             }
        };
        const handleResize = () => { clearTimeout(debounceTimer); debounceTimer = setTimeout(updateDimensions, RESIZE_DEBOUNCE_MS); };
        const initialTimeout = setTimeout(updateDimensions, 50);
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', handleResize);
        return () => { clearTimeout(initialTimeout); clearTimeout(debounceTimer); window.removeEventListener('resize', handleResize); window.removeEventListener('orientationchange', handleResize); };
    }, []); // Runs once

    // Effect to regenerate paths/flowers when dimensions change
     useEffect(() => {
        const timer = setTimeout(generateAllPathsAndFlowers, 100);
        return () => clearTimeout(timer);
    }, [generateAllPathsAndFlowers]); // Dependency on the memoized generation function

    // --- Scroll Progress Update Effect --- (No changes needed)
    useEffect(() => {
        const updateScrollProgress = () => {
            const scrollY = window.scrollY;
            const docHeight = document.documentElement.scrollHeight;
            const viewHeight = document.documentElement.clientHeight;
            const maxScroll = docHeight - viewHeight;
            const progress = maxScroll > 0 ? Math.min(1, Math.max(0, scrollY / maxScroll)) : 1;
            document.documentElement.style.setProperty('--scroll-progress', progress.toFixed(3));
        };
        updateScrollProgress();
        window.addEventListener('scroll', updateScrollProgress, { passive: true });
        return () => window.removeEventListener('scroll', updateScrollProgress);
    }, []);

    // --- Activity State Management Effect --- (No changes needed in logic, just state names)
    useEffect(() => {
        const setActivity = (newState: ActivityStateType, force: boolean = false) => {
            if (activityStateRef.current === 'window-inactive' && newState !== 'window-inactive' && !force) return;
            const priority: Record<ActivityStateType, number> = { 'window-inactive': 6, 'interacting': 5, 'scrolling-fast': 4, 'typing': 3, 'active': 2, 'idle': 1 };
            if (newState !== activityStateRef.current || force) {
                 const isTransitioningDown = (priority[activityStateRef.current] > priority[newState]) && (activityStateRef.current === 'interacting' || activityStateRef.current === 'scrolling-fast');
                 if (priority[newState] >= priority[activityStateRef.current] || force || isTransitioningDown) {
                    // console.log("Activity State Change:", activityStateRef.current, "->", newState);
                    setActivityState(newState);
                 } else { return; }
            }
            if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
            if (newState !== 'idle' && newState !== 'window-inactive' && newState !== 'interacting') {
                idleTimerRef.current = setTimeout(() => {
                    if (!['window-inactive', 'interacting', 'scrolling-fast', 'typing'].includes(activityStateRef.current)) {
                        setActivity('idle');
                    }
                }, IDLE_TIMEOUT_MS);
            }
        };
        const triggerInteraction = () => {
            if (activityStateRef.current === 'window-inactive') return;
            setActivity('interacting', true);
            if (interactionTimerRef.current) clearTimeout(interactionTimerRef.current);
            interactionTimerRef.current = setTimeout(() => {
                if (scrollStateRef.current.isScrollingFast) setActivity('scrolling-fast');
                else if (document.activeElement && ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) setActivity('typing');
                else setActivity('active');
            }, INTERACTION_TIMEOUT_MS);
             if (idleTimerRef.current) clearTimeout(idleTimerRef.current);
        };
        const handleScroll = () => {
            if (activityStateRef.current === 'window-inactive') return;
            const now = performance.now(); const currentY = window.scrollY;
            const timeDiff = now - scrollStateRef.current.lastTime; const scrollDiff = Math.abs(currentY - scrollStateRef.current.lastY);
            if (timeDiff > SCROLL_UPDATE_INTERVAL_MS) {
                const speed = scrollDiff / timeDiff * 100;
                scrollStateRef.current.isScrollingFast = speed > FAST_SCROLL_THRESHOLD;
                setActivity(scrollStateRef.current.isScrollingFast ? 'scrolling-fast' : 'active');
                scrollStateRef.current = { ...scrollStateRef.current, lastY: currentY, lastTime: now };
            } else if (activityStateRef.current !== 'interacting') {
                 setActivity(scrollStateRef.current.isScrollingFast ? 'scrolling-fast' : 'active');
            }
        };
        const handleMouseMove = () => { if (!['window-inactive', 'interacting', 'scrolling-fast', 'typing'].includes(activityStateRef.current)) setActivity('active'); };
        const handleClick = () => triggerInteraction();
        const handleKeydown = (event: KeyboardEvent) => { const target = event.target as HTMLElement; if (target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName)) { if (!['window-inactive', 'interacting'].includes(activityStateRef.current)) setActivity('typing'); } else triggerInteraction(); };
        const handleFocus = (event: FocusEvent) => { const target = event.target as HTMLElement; if (target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName)) { if (!['window-inactive', 'interacting'].includes(activityStateRef.current)) setActivity('typing'); } };
        const handleBlur = (event: FocusEvent) => { const target = event.target as HTMLElement; if (target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName)) { if (activityStateRef.current === 'typing') setActivity('active'); } };
        const handleWindowFocus = () => { if(activityStateRef.current === 'window-inactive') setActivity('active', true); };
        const handleWindowBlur = () => { setActivity('window-inactive', true); if (idleTimerRef.current) clearTimeout(idleTimerRef.current); if (interactionTimerRef.current) clearTimeout(interactionTimerRef.current); };

        window.addEventListener('scroll', handleScroll, { passive: true });
        window.addEventListener('mousemove', handleMouseMove, { passive: true });
        window.addEventListener('click', handleClick, { capture: true });
        window.addEventListener('keydown', handleKeydown, { capture: true });
        window.addEventListener('focus', handleFocus, true); window.addEventListener('blur', handleBlur, true);
        window.addEventListener('focus', handleWindowFocus); window.addEventListener('blur', handleWindowBlur);
        setActivity('active', true); // Initial state
        return () => { if (idleTimerRef.current) clearTimeout(idleTimerRef.current); if (interactionTimerRef.current) clearTimeout(interactionTimerRef.current); window.removeEventListener('scroll', handleScroll); window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('click', handleClick, { capture: true }); window.removeEventListener('keydown', handleKeydown, { capture: true }); window.removeEventListener('focus', handleFocus, true); window.removeEventListener('blur', handleBlur, true); window.removeEventListener('focus', handleWindowFocus); window.removeEventListener('blur', handleWindowBlur); };
    }, []); // Run once

    // --- SVG Gradient Definitions --- (No changes needed)
    const svgGradients = useMemo(() => (
        <defs>
            {/* Dark Mode Gradients */}
            <linearGradient id="vineGradientIdle1Dark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-secondary)" stopOpacity="0.3"/><stop offset="100%" stopColor="var(--accent-muted1)" stopOpacity="0.5"/></linearGradient>
            <linearGradient id="vineGradientIdle2Dark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-muted2)" stopOpacity="0.2"/><stop offset="100%" stopColor="var(--accent-secondary)" stopOpacity="0.4"/></linearGradient>
            <linearGradient id="vineGradientActive1Dark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-primary)" stopOpacity="0.5"/><stop offset="100%" stopColor="var(--accent-highlight)" stopOpacity="0.7"/></linearGradient>
            <linearGradient id="vineGradientActive2Dark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-highlight)" stopOpacity="0.4"/><stop offset="100%" stopColor="var(--accent-secondary)" stopOpacity="0.6"/></linearGradient>
            <linearGradient id="vineGradientTypingDark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-primary)" stopOpacity="0.6"/><stop offset="100%" stopColor="var(--accent-secondary)" stopOpacity="0.8"/></linearGradient>
            <linearGradient id="vineGradientAlertDark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-alert)" stopOpacity="0.7"/><stop offset="100%" stopColor="var(--accent-primary)" stopOpacity="0.9"/></linearGradient>
            <linearGradient id="vineGradientInteractDark" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-highlight)" stopOpacity="0.9"/><stop offset="50%" stopColor="var(--accent-primary)" stopOpacity="0.8"/><stop offset="100%" stopColor="var(--accent-secondary)" stopOpacity="0.7"/></linearGradient>
            {/* Light Mode Gradients */}
            <linearGradient id="vineGradientIdle1Light" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-secondary-light)" stopOpacity="0.35"/><stop offset="100%" stopColor="var(--accent-muted1-light)" stopOpacity="0.55"/></linearGradient>
            <linearGradient id="vineGradientIdle2Light" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-muted2-light)" stopOpacity="0.25"/><stop offset="100%" stopColor="var(--accent-secondary-light)" stopOpacity="0.45"/></linearGradient>
            <linearGradient id="vineGradientActive1Light" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-primary-light)" stopOpacity="0.6"/><stop offset="100%" stopColor="var(--accent-highlight-light)" stopOpacity="0.8"/></linearGradient>
            <linearGradient id="vineGradientActive2Light" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-highlight-light)" stopOpacity="0.5"/><stop offset="100%" stopColor="var(--accent-secondary-light)" stopOpacity="0.7"/></linearGradient>
            <linearGradient id="vineGradientTypingLight" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-primary-light)" stopOpacity="0.65"/><stop offset="100%" stopColor="var(--accent-secondary-light)" stopOpacity="0.85"/></linearGradient>
            <linearGradient id="vineGradientAlertLight" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-alert-light)" stopOpacity="0.75"/><stop offset="100%" stopColor="var(--accent-primary-light)" stopOpacity="0.95"/></linearGradient>
            <linearGradient id="vineGradientInteractLight" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="var(--accent-highlight-light)" stopOpacity="0.95"/><stop offset="50%" stopColor="var(--accent-primary-light)" stopOpacity="0.85"/><stop offset="100%" stopColor="var(--accent-secondary-light)" stopOpacity="0.75"/></linearGradient>
        </defs>
    ), []);

    // --- Determine Theme Class ---
    // This assumes you have a way to detect the current theme (e.g., from context, props, or global class)
    // Replace this with your actual theme detection logic
    const isLightMode = typeof window !== 'undefined' && document.body.classList.contains('light');
    const flowerBaseColorVar = isLightMode ? '--flower-color-base-light' : '--flower-color-base';
    const flowerAltColorVar = isLightMode ? '--flower-color-alt-light' : '--flower-color-alt';


    return (
        <div className={styles.vinesContainer}>
            <svg
                ref={svgRef}
                id="blog-vine-svg"
                width="100%" height="100%"
                preserveAspectRatio="none"
                className={styles.vinesSvg}
                data-activity-state={activityState} // CSS uses this for state styling
            >
                {/* Include the defined gradients */}
                {svgGradients}

                {/* Render Vine Paths */}
                {allPaths.map(({ pathD, strokeVar, delay }, index) => (
                    <path
                        key={`path-${index}`}
                        d={pathD}
                        className={styles.vinePath}
                        style={{
                            animationDelay: delay,
                            ['--random-stroke-variation' as any]: strokeVar,
                        }}
                    />
                ))}

                {/* --- New: Render Flowers --- */}
                {allFlowers.map((flower, index) => (
                    <circle
                        key={`flower-${index}`}
                        className={styles.vineFlower}
                        cx={flower.cx.toFixed(1)} // Use fixed precision for SVG attributes
                        cy={flower.cy.toFixed(1)}
                        r={flower.r.toFixed(1)}
                        style={{
                            animationDelay: flower.delay,
                            // Set fill color directly based on colorVar and theme
                            // Uses CSS variables defined in BlogVines.module.css
                            fill: `var(${flower.colorVar > FLOWER_ALT_COLOR_THRESHOLD ? flowerAltColorVar : flowerBaseColorVar})`,
                        }}
                    />
                ))}
            </svg>
        </div>
    );
};

export default BlogVines;
