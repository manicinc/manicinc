{"version":3,"file":"static/chunks/markdown-58365fb3c8884b67.js","mappings":"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","sources":["webpack://_N_E/./node_modules/mdast-util-to-string/lib/index.js","webpack://_N_E/./node_modules/mdast-util-from-markdown/lib/index.js","webpack://_N_E/./node_modules/remark-parse/lib/index.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/footer.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/blockquote.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/break.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/code.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/delete.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/emphasis.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/heading.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/html.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/revert.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/image-reference.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/image.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/inline-code.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/link-reference.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/link.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/list-item.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/list.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/paragraph.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/root.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/strong.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/table.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/table-row.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/table-cell.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/text.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/handlers/index.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/state.js","webpack://_N_E/./node_modules/mdast-util-to-hast/lib/index.js","webpack://_N_E/./node_modules/remark-rehype/lib/index.js","webpack://_N_E/./node_modules/unified/lib/callable-instance.js","webpack://_N_E/./node_modules/unified/lib/index.js","webpack://_N_E/./node_modules/react-markdown/lib/index.js","webpack://_N_E/./node_modules/rehype-autolink-headings/lib/index.js","webpack://_N_E/./node_modules/rehype-katex/lib/index.js","webpack://_N_E/./node_modules/rehype-raw/lib/index.js","webpack://_N_E/./node_modules/rehype-slug/lib/index.js","webpack://_N_E/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","webpack://_N_E/./node_modules/mdast-util-find-and-replace/lib/index.js","webpack://_N_E/./node_modules/mdast-util-gfm-autolink-literal/lib/index.js","webpack://_N_E/./node_modules/mdast-util-gfm-footnote/lib/index.js","webpack://_N_E/./node_modules/mdast-util-gfm-strikethrough/lib/index.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/break.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-fence.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/code.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/definition.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/encode-info.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/heading.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/html.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/image.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/link.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-rule.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/list.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js","webpack://_N_E/./node_modules/mdast-util-phrasing/lib/index.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/root.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-strong.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/strong.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/text.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js","webpack://_N_E/./node_modules/mdast-util-to-markdown/lib/handle/index.js","webpack://_N_E/./node_modules/mdast-util-gfm-table/lib/index.js","webpack://_N_E/./node_modules/mdast-util-gfm-task-list-item/lib/index.js","webpack://_N_E/./node_modules/mdast-util-gfm/lib/index.js","webpack://_N_E/./node_modules/remark-gfm/lib/index.js","webpack://_N_E/./node_modules/mdast-util-math/lib/index.js","webpack://_N_E/./node_modules/remark-math/lib/index.js","webpack://_N_E/./node_modules/remark-unwrap-images/lib/index.js","webpack://_N_E/./node_modules/unist-util-find-after/lib/index.js","webpack://_N_E/./node_modules/unist-util-is/lib/index.js","webpack://_N_E/./node_modules/unist-util-position/lib/index.js","webpack://_N_E/./node_modules/unist-util-stringify-position/lib/index.js","webpack://_N_E/./node_modules/unist-util-visit-parents/lib/color.js","webpack://_N_E/./node_modules/unist-util-visit-parents/lib/index.js","webpack://_N_E/./node_modules/unist-util-visit/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Nodes} Nodes\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s (default: `true`).\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML (default: `true`).\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the nodes plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} [value]\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Nodes}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @import {\n *   Break,\n *   Blockquote,\n *   Code,\n *   Definition,\n *   Emphasis,\n *   Heading,\n *   Html,\n *   Image,\n *   InlineCode,\n *   Link,\n *   ListItem,\n *   List,\n *   Nodes,\n *   Paragraph,\n *   PhrasingContent,\n *   ReferenceType,\n *   Root,\n *   Strong,\n *   Text,\n *   ThematicBreak\n * } from 'mdast'\n * @import {\n *   Encoding,\n *   Event,\n *   Token,\n *   Value\n * } from 'micromark-util-types'\n * @import {Point} from 'unist'\n * @import {\n *   CompileContext,\n *   CompileData,\n *   Config,\n *   Extension,\n *   Handle,\n *   OnEnterError,\n *   Options\n * } from './types.js'\n */\n\nimport { toString } from 'mdast-util-to-string';\nimport { parse, postprocess, preprocess } from 'micromark';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nconst own = {}.hasOwnProperty;\n\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n}\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      characterReference: onexitcharacterreference,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  };\n  configure(config, (options || {}).mdastExtensions || []);\n\n  /** @type {CompileData} */\n  const data = {};\n  return compile;\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    };\n    /** @type {Array<number>} */\n    const listStack = [];\n    let index = -1;\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === \"listOrdered\" || events[index][1].type === \"listUnordered\") {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1];\n      const handler = tail[1] || defaultOnError;\n      handler.call(context, undefined, tail[0]);\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    };\n\n    // Call transforms.\n    index = -1;\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n    return tree;\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token | undefined} */\n    let listItem;\n    /** @type {number | undefined} */\n    let lineIndex;\n    /** @type {number | undefined} */\n    let firstBlankLineIndex;\n    /** @type {boolean | undefined} */\n    let atMarker;\n    while (++index <= length) {\n      const event = events[index];\n      switch (event[1].type) {\n        case \"listUnordered\":\n        case \"listOrdered\":\n        case \"blockQuote\":\n          {\n            if (event[0] === 'enter') {\n              containerBalance++;\n            } else {\n              containerBalance--;\n            }\n            atMarker = undefined;\n            break;\n          }\n        case \"lineEndingBlank\":\n          {\n            if (event[0] === 'enter') {\n              if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                firstBlankLineIndex = index;\n              }\n              atMarker = undefined;\n            }\n            break;\n          }\n        case \"linePrefix\":\n        case \"listItemValue\":\n        case \"listItemMarker\":\n        case \"listItemPrefix\":\n        case \"listItemPrefixWhitespace\":\n          {\n            // Empty.\n\n            break;\n          }\n        default:\n          {\n            atMarker = undefined;\n          }\n      }\n      if (!containerBalance && event[0] === 'enter' && event[1].type === \"listItemPrefix\" || containerBalance === -1 && event[0] === 'exit' && (event[1].type === \"listUnordered\" || event[1].type === \"listOrdered\")) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n            if (tailEvent[1].type === \"lineEnding\" || tailEvent[1].type === \"lineEndingBlank\") {\n              if (tailEvent[0] === 'exit') continue;\n              if (lineIndex) {\n                events[lineIndex][1].type = \"lineEndingBlank\";\n                listSpread = true;\n              }\n              tailEvent[1].type = \"lineEnding\";\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === \"linePrefix\" || tailEvent[1].type === \"blockQuotePrefix\" || tailEvent[1].type === \"blockQuotePrefixWhitespace\" || tailEvent[1].type === \"blockQuoteMarker\" || tailEvent[1].type === \"listItemIndent\") {\n              // Empty\n            } else {\n              break;\n            }\n          }\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            listItem._spread = true;\n          }\n\n          // Fix position.\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        }\n\n        // Create a new list item.\n        if (event[1].type === \"listItemPrefix\") {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: well add `end` in a second.\n            end: undefined\n          };\n          listItem = item;\n          events.splice(index, 0, ['enter', item, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    }\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open;\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n\n  /**\n   * @type {CompileContext['buffer']}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n\n  /**\n   * @type {CompileContext['enter']}\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children;\n    siblings.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler || undefined]);\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    };\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close;\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n\n  /**\n   * @type {CompileContext['exit']}\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop();\n    const open = this.tokenStack.pop();\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): its not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        const handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n    node.position.end = point(token.end);\n  }\n\n  /**\n   * @type {CompileContext['resume']}\n   */\n  function resume() {\n    return toString(this.stack.pop());\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      this.data.expectingFirstListItemValue = undefined;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return;\n    this.buffer();\n    this.data.flowCodeInside = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    this.data.flowCodeInside = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = node.children;\n    let tail = siblings[siblings.length - 1];\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text();\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: well add `end` later.\n        end: undefined\n      };\n      siblings.push(tail);\n    }\n    this.stack.push(tail);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1];\n    // If were at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      const tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      this.data.atHardBreak = undefined;\n      return;\n    }\n    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token);\n    const ancestor = this.stack[this.stack.length - 2];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string);\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // Assume a reference.\n    this.data.inReference = true;\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children;\n      node.children = children;\n    } else {\n      node.alt = value;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed';\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label;\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    this.data.referenceType = 'full';\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    this.data.characterReferenceType = token.type;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = this.data.characterReferenceType;\n    /** @type {string} */\n    let value;\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === \"characterReferenceMarkerNumeric\" ? 10 : 16);\n      this.data.characterReferenceType = undefined;\n    } else {\n      const result = decodeNamedCharacterReference(data);\n      value = result;\n    }\n    const tail = this.stack[this.stack.length - 1];\n    tail.value += value;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreference(token) {\n    const tail = this.stack.pop();\n    tail.position.end = point(token.end);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    };\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    };\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  };\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\nfunction configure(combined, extensions) {\n  let index = -1;\n  while (++index < extensions.length) {\n    const value = extensions[index];\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key;\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'transforms':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'enter':\n        case 'exit':\n          {\n            const right = extension[key];\n            if (right) {\n              Object.assign(combined[key], right);\n            }\n            break;\n          }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').Options} FromMarkdownOptions\n * @typedef {import('unified').Parser<Root>} Parser\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\n/**\n * @typedef {Omit<FromMarkdownOptions, 'extensions' | 'mdastExtensions'>} Options\n */\n\nimport {fromMarkdown} from 'mdast-util-from-markdown'\n\n/**\n * Aadd support for parsing from markdown.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkParse(options) {\n  /** @type {Processor} */\n  // @ts-expect-error: TS in JSDoc generates wrong types if `this` is typed regularly.\n  const self = this\n\n  self.parser = parser\n\n  /**\n   * @type {Parser}\n   */\n  function parser(doc) {\n    return fromMarkdown(doc, {\n      ...self.data('settings'),\n      ...options,\n      // Note: these options are not in the readme.\n      // The goal is for them to be set by plugins on `data` instead of being\n      // passed by users.\n      extensions: self.data('micromarkExtensions') || [],\n      mdastExtensions: self.data('fromMarkdownExtensions') || []\n    })\n  }\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @callback FootnoteBackContentTemplate\n *   Generate content for the backreference dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent> | ElementContent | string}\n *   Content for the backreference when linking back from definitions to their\n *   reference.\n *\n * @callback FootnoteBackLabelTemplate\n *   Generate a back label dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Back label to use when linking back from definitions to their reference.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate the default content that GitHub uses on backreferences.\n *\n * @param {number} _\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent>}\n *   Content.\n */\nexport function defaultFootnoteBackContent(_, rereferenceIndex) {\n  /** @type {Array<ElementContent>} */\n  const result = [{type: 'text', value: ''}]\n\n  if (rereferenceIndex > 1) {\n    result.push({\n      type: 'element',\n      tagName: 'sup',\n      properties: {},\n      children: [{type: 'text', value: String(rereferenceIndex)}]\n    })\n  }\n\n  return result\n}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Label.\n */\nexport function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\n// eslint-disable-next-line complexity\nexport function footer(state) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const footnoteBackContent =\n    state.options.footnoteBackContent || defaultFootnoteBackContent\n  const footnoteBackLabel =\n    state.options.footnoteBackLabel || defaultFootnoteBackLabel\n  const footnoteLabel = state.options.footnoteLabel || 'Footnotes'\n  const footnoteLabelTagName = state.options.footnoteLabelTagName || 'h2'\n  const footnoteLabelProperties = state.options.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let referenceIndex = -1\n\n  while (++referenceIndex < state.footnoteOrder.length) {\n    const definition = state.footnoteById.get(\n      state.footnoteOrder[referenceIndex]\n    )\n\n    if (!definition) {\n      continue\n    }\n\n    const content = state.all(definition)\n    const id = String(definition.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let rereferenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n    const counts = state.footnoteCounts.get(id)\n\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (counts !== undefined && ++rereferenceIndex <= counts) {\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      let children =\n        typeof footnoteBackContent === 'string'\n          ? footnoteBackContent\n          : footnoteBackContent(referenceIndex, rereferenceIndex)\n\n      if (typeof children === 'string') {\n        children = {type: 'text', value: children}\n      }\n\n      backReferences.push({\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (rereferenceIndex > 1 ? '-' + rereferenceIndex : ''),\n          dataFootnoteBackref: '',\n          ariaLabel:\n            typeof footnoteBackLabel === 'string'\n              ? footnoteBackLabel\n              : footnoteBackLabel(referenceIndex, rereferenceIndex),\n          className: ['data-footnote-backref']\n        },\n        children: Array.isArray(children) ? children : [children]\n      })\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(definition, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: footnoteLabelTagName,\n        properties: {\n          ...structuredClone(footnoteLabelProperties),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  /** @type {Properties} */\n  const properties = {}\n\n  if (node.lang) {\n    properties.className = ['language-' + node.lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  let reuseCounter = state.footnoteCounts.get(id)\n\n  if (reuseCounter === undefined) {\n    reuseCounter = 0\n    state.footnoteOrder.push(id)\n    counter = state.footnoteOrder.length\n  } else {\n    counter = index + 1\n  }\n\n  reuseCounter += 1\n  state.footnoteCounts.set(id, reuseCounter)\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + clobberPrefix + 'fn-' + safeId,\n      id:\n        clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Html} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Element | Raw | undefined}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.options.allowDangerousHtml) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  return undefined\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Reference} Reference\n *\n * @typedef {import('./state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Extract<Nodes, Reference>} node\n *   Reference node (image, link).\n * @returns {Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return [{type: 'text', value: '![' + node.alt + suffix}]\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(definition.url || ''), alt: node.alt}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(definition.url || '')}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === null || spread === undefined\n    ? node.children.length > 1\n    : spread\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Parents} HastParents\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastParents}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointEnd, pointStart} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start && end) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  // To do: option to use `style`?\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(cell, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastElement | HastText}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n *\n * @satisfies {import('../state.js').Handlers}\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  // @ts-expect-error: root is different, but hard to type.\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  return undefined\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: ''}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the ``\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a nodes positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesnt understand\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesnt understand\n        return result\n      }\n\n      // @ts-expect-error: its custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a nodes positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n","/**\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('./state.js').Options} Options\n */\n\nimport {ok as assert} from 'devlop'\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones dont:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isnt in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesnt have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   hast tree.\n */\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, undefined)\n  const foot = footer(state)\n  /** @type {HastNodes} */\n  const result = Array.isArray(node)\n    ? {type: 'root', children: node}\n    : node || {type: 'root', children: []}\n\n  if (foot) {\n    // If theres a footer, there were definitions, meaning block\n    // content.\n    // So `result` is a parent node.\n    assert('children' in result)\n    result.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  return result\n}\n","/**\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {Options as ToHastOptions} from 'mdast-util-to-hast'\n * @import {Processor} from 'unified'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @typedef {Omit<ToHastOptions, 'file'>} Options\n *\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new hast tree.\n *   Discards result.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the hast tree.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {HastRoot}\n *   Tree (hast).\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n/**\n * Turn markdown into HTML.\n *\n * ##### Notes\n *\n * ###### Signature\n *\n * * if a processor is given,\n *   runs the (rehype) plugins used on it with a hast tree,\n *   then discards the result (*bridge mode*)\n * * otherwise,\n *   returns a hast tree,\n *   the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n *\n * >  **Note**:\n * > Its highly unlikely that you want to pass a `processor`.\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most plugins ignore `raw` nodes but two notable ones dont:\n *\n * * `rehype-stringify` also has an option `allowDangerousHtml` which will\n *   output the raw HTML.\n *   This is typically discouraged as noted by the option name but is useful if\n *   you completely trust authors\n * * `rehype-raw` can handle the raw embedded HTML strings by parsing them\n *   into standard hast nodes (`element`, `text`, etc);\n *   this is a heavy task as it needs a full HTML parser,\n *   but it is the only way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark,\n * which we follow by default.\n * They are supported by GitHub,\n * so footnotes can be enabled in markdown with `remark-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes,\n * which is hidden for sighted users but shown to assistive technology.\n * When your page is not in English,\n * you must define translated values.\n *\n * Back references use ARIA attributes,\n * but the section label itself uses a heading that is hidden with an\n * `sr-only` class.\n * To show it to sighted users,\n * define different attributes in `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem,\n * as it links footnote calls to footnote definitions on the page through `id`\n * attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * *Example: headings (DOM clobbering)* in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isnt in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * * when the node has a `value`\n *   (and doesnt have `data.hName`, `data.hProperties`, or `data.hChildren`,\n *   see later),\n *   create a hast `text` node\n * * otherwise,\n *   create a `<div>` element (which could be changed with `data.hName`),\n *   with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @overload\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge | TransformMutate}\n *\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Readonly<Options> | null | undefined} [options]\n *   When a processor was given,\n *   configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function remarkRehype(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      // Cast because root in -> root out.\n      const hastTree = /** @type {HastRoot} */ (\n        toHast(tree, {file, ...options})\n      )\n      await destination.run(hastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree, file) {\n    // Cast because root in -> root out.\n    // To do: in the future, disallow ` || options` fallback.\n    // With `unified-engine`, `destination` can be `undefined` but\n    // `options` will be the file set.\n    // We should not pass that as `options`.\n    return /** @type {HastRoot} */ (\n      toHast(tree, {file, ...(destination || options)})\n    )\n  }\n}\n","export const CallableInstance =\n  /**\n   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}\n   */\n  (\n    /** @type {unknown} */\n    (\n      /**\n       * @this {Function}\n       * @param {string | symbol} property\n       * @returns {(...parameters: Array<unknown>) => unknown}\n       */\n      function (property) {\n        const self = this\n        const constr = self.constructor\n        const proto = /** @type {Record<string | symbol, Function>} */ (\n          // Prototypes do exist.\n          // type-coverage:ignore-next-line\n          constr.prototype\n        )\n        const value = proto[property]\n        /** @type {(...parameters: Array<unknown>) => unknown} */\n        const apply = function () {\n          return value.apply(apply, arguments)\n        }\n\n        Object.setPrototypeOf(apply, proto)\n\n        // Not needed for us in `unified`: we only call this on the `copy`\n        // function,\n        // and we don't need to add its fields (`length`, `name`)\n        // over.\n        // See also: GH-246.\n        // const names = Object.getOwnPropertyNames(value)\n        //\n        // for (const p of names) {\n        //   const descriptor = Object.getOwnPropertyDescriptor(value, p)\n        //   if (descriptor) Object.defineProperty(apply, p, descriptor)\n        // }\n\n        return apply\n      }\n    )\n  )\n","/**\n * @typedef {import('trough').Pipeline} Pipeline\n *\n * @typedef {import('unist').Node} Node\n *\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('vfile').Value} Value\n *\n * @typedef {import('../index.js').CompileResultMap} CompileResultMap\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Settings} Settings\n */\n\n/**\n * @typedef {CompileResultMap[keyof CompileResultMap]} CompileResults\n *   Acceptable results from compilers.\n *\n *   To register custom results, add them to\n *   {@linkcode CompileResultMap}.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the compiler receives (default: `Node`).\n * @template {CompileResults} [Result=CompileResults]\n *   The thing that the compiler yields (default: `CompileResults`).\n * @callback Compiler\n *   A **compiler** handles the compiling of a syntax tree to something else\n *   (in most cases, text) (TypeScript type).\n *\n *   It is used in the stringify phase and called with a {@linkcode Node}\n *   and {@linkcode VFile} representation of the document to compile.\n *   It should return the textual representation of the given tree (typically\n *   `string`).\n *\n *   > **Note**: unified typically compiles by serializing: most compilers\n *   > return `string` (or `Uint8Array`).\n *   > Some compilers, such as the one configured with\n *   > [`rehype-react`][rehype-react], return other values (in this case, a\n *   > React tree).\n *   > If youre using a compiler that doesnt serialize, expect different\n *   > result values.\n *   >\n *   > To register custom results in TypeScript, add them to\n *   > {@linkcode CompileResultMap}.\n *\n *   [rehype-react]: https://github.com/rehypejs/rehype-react\n * @param {Tree} tree\n *   Tree to compile.\n * @param {VFile} file\n *   File associated with `tree`.\n * @returns {Result}\n *   New content: compiled text (`string` or `Uint8Array`, for `file.value`) or\n *   something else (for `file.result`).\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the parser yields (default: `Node`)\n * @callback Parser\n *   A **parser** handles the parsing of text to a syntax tree.\n *\n *   It is used in the parse phase and is called with a `string` and\n *   {@linkcode VFile} of the document to parse.\n *   It must return the syntax tree representation of the given file\n *   ({@linkcode Node}).\n * @param {string} document\n *   Document to parse.\n * @param {VFile} file\n *   File associated with `document`.\n * @returns {Tree}\n *   Node representing the given file.\n */\n\n/**\n * @typedef {(\n *   Plugin<Array<any>, any, any> |\n *   PluginTuple<Array<any>, any, any> |\n *   Preset\n * )} Pluggable\n *   Union of the different ways to add plugins and settings.\n */\n\n/**\n * @typedef {Array<Pluggable>} PluggableList\n *   List of plugins and presets.\n */\n\n// Note: we cant use `callback` yet as it messes up `this`:\n//  <https://github.com/microsoft/TypeScript/issues/55197>.\n/**\n * @template {Array<unknown>} [PluginParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=Node]\n *   Value that is expected as input (default: `Node`).\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@linkcode Parser}, this should be\n *       `string`.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be the\n *       node it expects.\n * @template [Output=Input]\n *   Value that is yielded as output (default: `Input`).\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@linkcode Parser}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be\n *       result it yields.\n * @typedef {(\n *   (this: Processor, ...parameters: PluginParameters) =>\n *     Input extends string ? // Parser.\n *        Output extends Node | undefined ? undefined | void : never :\n *     Output extends CompileResults ? // Compiler.\n *        Input extends Node | undefined ? undefined | void : never :\n *     Transformer<\n *       Input extends Node ? Input : Node,\n *       Output extends Node ? Output : Node\n *     > | undefined | void\n * )} Plugin\n *   Single plugin.\n *\n *   Plugins configure the processors they are applied on in the following\n *   ways:\n *\n *   *   they change the processor, such as the parser, the compiler, or by\n *       configuring data\n *   *   they specify how to handle trees and files\n *\n *   In practice, they are functions that can receive options and configure the\n *   processor (`this`).\n *\n *   > **Note**: plugins are called when the processor is *frozen*, not when\n *   > they are applied.\n */\n\n/**\n * Tuple of a plugin and its configuration.\n *\n * The first item is a plugin, the rest are its parameters.\n *\n * @template {Array<unknown>} [TupleParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=undefined]\n *   Value that is expected as input (optional).\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@linkcode Parser}, this should be\n *       `string`.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be the\n *       node it expects.\n * @template [Output=undefined] (optional).\n *   Value that is yielded as output.\n *\n *   *   If the plugin returns a {@linkcode Transformer}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@linkcode Parser}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@linkcode Compiler}, this should be\n *       result it yields.\n * @typedef {(\n *   [\n *     plugin: Plugin<TupleParameters, Input, Output>,\n *     ...parameters: TupleParameters\n *   ]\n * )} PluginTuple\n */\n\n/**\n * @typedef Preset\n *   Sharable configuration.\n *\n *   They can contain plugins and settings.\n * @property {PluggableList | undefined} [plugins]\n *   List of plugins and presets (optional).\n * @property {Settings | undefined} [settings]\n *   Shared settings for parsers and compilers (optional).\n */\n\n/**\n * @template {VFile} [File=VFile]\n *   The file that the callback receives (default: `VFile`).\n * @callback ProcessCallback\n *   Callback called when the process is done.\n *\n *   Called with either an error or a result.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {File | undefined} [file]\n *   Processed file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The tree that the callback receives (default: `Node`).\n * @callback RunCallback\n *   Callback called when transformers are done.\n *\n *   Called with either an error or results.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {Tree | undefined} [tree]\n *   Transformed tree (optional).\n * @param {VFile | undefined} [file]\n *   File (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Output=Node]\n *   Node type that the transformer yields (default: `Node`).\n * @callback TransformCallback\n *   Callback passed to transforms.\n *\n *   If the signature of a `transformer` accepts a third argument, the\n *   transformer may perform asynchronous operations, and must call it.\n * @param {Error | undefined} [error]\n *   Fatal error to stop the process (optional).\n * @param {Output | undefined} [tree]\n *   New, changed, tree (optional).\n * @param {VFile | undefined} [file]\n *   New, changed, file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Input=Node]\n *   Node type that the transformer expects (default: `Node`).\n * @template {Node} [Output=Input]\n *   Node type that the transformer yields (default: `Input`).\n * @callback Transformer\n *   Transformers handle syntax trees and files.\n *\n *   They are functions that are called each time a syntax tree and file are\n *   passed through the run phase.\n *   When an error occurs in them (either because its thrown, returned,\n *   rejected, or passed to `next`), the process stops.\n *\n *   The run phase is handled by [`trough`][trough], see its documentation for\n *   the exact semantics of these functions.\n *\n *   > **Note**: you should likely ignore `next`: dont accept it.\n *   > it supports callback-style async work.\n *   > But promises are likely easier to reason about.\n *\n *   [trough]: https://github.com/wooorm/trough#function-fninput-next\n * @param {Input} tree\n *   Tree to handle.\n * @param {VFile} file\n *   File to handle.\n * @param {TransformCallback<Output>} next\n *   Callback.\n * @returns {(\n *   Promise<Output | undefined | void> |\n *   Promise<never> | // For some reason this is needed separately.\n *   Output |\n *   Error |\n *   undefined |\n *   void\n * )}\n *   If you accept `next`, nothing.\n *   Otherwise:\n *\n *   *   `Error`  fatal error to stop the process\n *   *   `Promise<undefined>` or `undefined`  the next transformer keeps using\n *       same tree\n *   *   `Promise<Node>` or `Node`  new, changed, tree\n */\n\n/**\n * @template {Node | undefined} ParseTree\n *   Output of `parse`.\n * @template {Node | undefined} HeadTree\n *   Input for `run`.\n * @template {Node | undefined} TailTree\n *   Output for `run`.\n * @template {Node | undefined} CompileTree\n *   Input of `stringify`.\n * @template {CompileResults | undefined} CompileResult\n *   Output of `stringify`.\n * @template {Node | string | undefined} Input\n *   Input of plugin.\n * @template Output\n *   Output of plugin (optional).\n * @typedef {(\n *   Input extends string\n *     ? Output extends Node | undefined\n *       ? // Parser.\n *         Processor<\n *           Output extends undefined ? ParseTree : Output,\n *           HeadTree,\n *           TailTree,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Output extends CompileResults\n *     ? Input extends Node | undefined\n *       ? // Compiler.\n *         Processor<\n *           ParseTree,\n *           HeadTree,\n *           TailTree,\n *           Input extends undefined ? CompileTree : Input,\n *           Output extends undefined ? CompileResult : Output\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Input extends Node | undefined\n *     ? Output extends Node | undefined\n *       ? // Transform.\n *         Processor<\n *           ParseTree,\n *           HeadTree extends undefined ? Input : HeadTree,\n *           Output extends undefined ? TailTree : Output,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : // Unknown.\n *       Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n * )} UsePlugin\n *   Create a processor based on the input/output of a {@link Plugin plugin}.\n */\n\n/**\n * @template {CompileResults | undefined} Result\n *   Node type that the transformer yields.\n * @typedef {(\n *   Result extends Value | undefined ?\n *     VFile :\n *     VFile & {result: Result}\n *   )} VFileWithOutput\n *   Type to generate a {@linkcode VFile} corresponding to a compiler result.\n *\n *   If a result that is not acceptable on a `VFile` is used, that will\n *   be stored on the `result` field of {@linkcode VFile}.\n */\n\nimport {bail} from 'bail'\nimport extend from 'extend'\nimport {ok as assert} from 'devlop'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\nimport {CallableInstance} from './callable-instance.js'\n\n// To do: next major: drop `Compiler`, `Parser`: prefer lowercase.\n\n// To do: we could start yielding `never` in TS when a parser is missing and\n// `parse` is called.\n// Currently, we allow directly setting `processor.parser`, which is untyped.\n\nconst own = {}.hasOwnProperty\n\n/**\n * @template {Node | undefined} [ParseTree=undefined]\n *   Output of `parse` (optional).\n * @template {Node | undefined} [HeadTree=undefined]\n *   Input for `run` (optional).\n * @template {Node | undefined} [TailTree=undefined]\n *   Output for `run` (optional).\n * @template {Node | undefined} [CompileTree=undefined]\n *   Input of `stringify` (optional).\n * @template {CompileResults | undefined} [CompileResult=undefined]\n *   Output of `stringify` (optional).\n * @extends {CallableInstance<[], Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>>}\n */\nexport class Processor extends CallableInstance {\n  /**\n   * Create a processor.\n   */\n  constructor() {\n    // If `Processor()` is called (w/o new), `copy` is called instead.\n    super('copy')\n\n    /**\n     * Compiler to use (deprecated).\n     *\n     * @deprecated\n     *   Use `compiler` instead.\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    this.Compiler = undefined\n\n    /**\n     * Parser to use (deprecated).\n     *\n     * @deprecated\n     *   Use `parser` instead.\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    this.Parser = undefined\n\n    // Note: the following fields are considered private.\n    // However, they are needed for tests, and TSC generates an untyped\n    // `private freezeIndex` field for, which trips `type-coverage` up.\n    // Instead, we use `@deprecated` to visualize that they shouldnt be used.\n    /**\n     * Internal list of configured plugins.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Array<PluginTuple<Array<unknown>>>}\n     */\n    this.attachers = []\n\n    /**\n     * Compiler to use.\n     *\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    this.compiler = undefined\n\n    /**\n     * Internal state to track where we are while freezing.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {number}\n     */\n    this.freezeIndex = -1\n\n    /**\n     * Internal state to track whether were frozen.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {boolean | undefined}\n     */\n    this.frozen = undefined\n\n    /**\n     * Internal state.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Data}\n     */\n    this.namespace = {}\n\n    /**\n     * Parser to use.\n     *\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    this.parser = undefined\n\n    /**\n     * Internal list of configured transformers.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Pipeline}\n     */\n    this.transformers = trough()\n  }\n\n  /**\n   * Copy a processor.\n   *\n   * @deprecated\n   *   This is a private internal method and should not be used.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   New *unfrozen* processor ({@linkcode Processor}) that is\n   *   configured to work the same as its ancestor.\n   *   When the descendant processor is configured in the future it does not\n   *   affect the ancestral processor.\n   */\n  copy() {\n    // Cast as the type parameters will be the same after attaching.\n    const destination =\n      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */ (\n        new Processor()\n      )\n    let index = -1\n\n    while (++index < this.attachers.length) {\n      const attacher = this.attachers[index]\n      destination.use(...attacher)\n    }\n\n    destination.data(extend(true, {}, this.namespace))\n\n    return destination\n  }\n\n  /**\n   * Configure the processor with info available to all plugins.\n   * Information is stored in an object.\n   *\n   * Typically, options can be given to a specific plugin, but sometimes it\n   * makes sense to have information shared with several plugins.\n   * For example, a list of HTML elements that are self-closing, which is\n   * needed during all phases.\n   *\n   * > **Note**: setting information cannot occur on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * > **Note**: to register custom data in TypeScript, augment the\n   * > {@linkcode Data} interface.\n   *\n   * @example\n   *   This example show how to get and set info:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   const processor = unified().data('alpha', 'bravo')\n   *\n   *   processor.data('alpha') // => 'bravo'\n   *\n   *   processor.data() // => {alpha: 'bravo'}\n   *\n   *   processor.data({charlie: 'delta'})\n   *\n   *   processor.data() // => {charlie: 'delta'}\n   *   ```\n   *\n   * @template {keyof Data} Key\n   *\n   * @overload\n   * @returns {Data}\n   *\n   * @overload\n   * @param {Data} dataset\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Key} key\n   * @returns {Data[Key]}\n   *\n   * @overload\n   * @param {Key} key\n   * @param {Data[Key]} value\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @param {Data | Key} [key]\n   *   Key to get or set, or entire dataset to set, or nothing to get the\n   *   entire dataset (optional).\n   * @param {Data[Key]} [value]\n   *   Value to set (optional).\n   * @returns {unknown}\n   *   The current processor when setting, the value at `key` when getting, or\n   *   the entire dataset when getting without key.\n   */\n  data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', this.frozen)\n        this.namespace[key] = value\n        return this\n      }\n\n      // Get `key`.\n      return (own.call(this.namespace, key) && this.namespace[key]) || undefined\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', this.frozen)\n      this.namespace = key\n      return this\n    }\n\n    // Get space.\n    return this.namespace\n  }\n\n  /**\n   * Freeze a processor.\n   *\n   * Frozen processors are meant to be extended and not to be configured\n   * directly.\n   *\n   * When a processor is frozen it cannot be unfrozen.\n   * New processors working the same way can be created by calling the\n   * processor.\n   *\n   * Its possible to freeze processors explicitly by calling `.freeze()`.\n   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,\n   * `.stringify()`, `.process()`, or `.processSync()` are called.\n   *\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   The current processor.\n   */\n  freeze() {\n    if (this.frozen) {\n      return this\n    }\n\n    // Cast so that we can type plugins easier.\n    // Plugins are supposed to be usable on different processors, not just on\n    // this exact processor.\n    const self = /** @type {Processor} */ (/** @type {unknown} */ (this))\n\n    while (++this.freezeIndex < this.attachers.length) {\n      const [attacher, ...options] = this.attachers[this.freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      const transformer = attacher.call(self, ...options)\n\n      if (typeof transformer === 'function') {\n        this.transformers.use(transformer)\n      }\n    }\n\n    this.frozen = true\n    this.freezeIndex = Number.POSITIVE_INFINITY\n\n    return this\n  }\n\n  /**\n   * Parse text to a syntax tree.\n   *\n   * > **Note**: `parse` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `parse` performs the parse phase, not the run phase or other\n   * > phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   file to parse (optional); typically `string` or `VFile`; any value\n   *   accepted as `x` in `new VFile(x)`.\n   * @returns {ParseTree extends undefined ? Node : ParseTree}\n   *   Syntax tree representing `file`.\n   */\n  parse(file) {\n    this.freeze()\n    const realFile = vfile(file)\n    const parser = this.parser || this.Parser\n    assertParser('parse', parser)\n    return parser(String(realFile), realFile)\n  }\n\n  /**\n   * Process the given file as configured on the processor.\n   *\n   * > **Note**: `process` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `process` performs the parse, run, and stringify phases.\n   *\n   * @overload\n   * @param {Compatible | undefined} file\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<VFileWithOutput<CompileResult>>}\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`]; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]\n   *   Callback (optional).\n   * @returns {Promise<VFile> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise a promise, rejected with a fatal error or resolved with the\n   *   processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youre using a compiler that doesnt serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@linkcode CompileResultMap}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  process(file, done) {\n    const self = this\n\n    this.freeze()\n    assertParser('process', this.parser || this.Parser)\n    assertCompiler('process', this.compiler || this.Compiler)\n\n    return done ? executor(undefined, done) : new Promise(executor)\n\n    // Note: `void`s needed for TS.\n    /**\n     * @param {((file: VFileWithOutput<CompileResult>) => undefined | void) | undefined} resolve\n     * @param {(error: Error | undefined) => undefined | void} reject\n     * @returns {undefined}\n     */\n    function executor(resolve, reject) {\n      const realFile = vfile(file)\n      // Assume `ParseTree` (the result of the parser) matches `HeadTree` (the\n      // input of the first transform).\n      const parseTree =\n        /** @type {HeadTree extends undefined ? Node : HeadTree} */ (\n          /** @type {unknown} */ (self.parse(realFile))\n        )\n\n      self.run(parseTree, realFile, function (error, tree, file) {\n        if (error || !tree || !file) {\n          return realDone(error)\n        }\n\n        // Assume `TailTree` (the output of the last transform) matches\n        // `CompileTree` (the input of the compiler).\n        const compileTree =\n          /** @type {CompileTree extends undefined ? Node : CompileTree} */ (\n            /** @type {unknown} */ (tree)\n          )\n\n        const compileResult = self.stringify(compileTree, file)\n\n        if (looksLikeAValue(compileResult)) {\n          file.value = compileResult\n        } else {\n          file.result = compileResult\n        }\n\n        realDone(error, /** @type {VFileWithOutput<CompileResult>} */ (file))\n      })\n\n      /**\n       * @param {Error | undefined} error\n       * @param {VFileWithOutput<CompileResult> | undefined} [file]\n       * @returns {undefined}\n       */\n      function realDone(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          assert(done, '`done` is defined if `resolve` is not')\n          done(undefined, file)\n        }\n      }\n    }\n  }\n\n  /**\n   * Process the given file as configured on the processor.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > **Note**: `processSync` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `processSync` performs the parse, run, and stringify phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @returns {VFileWithOutput<CompileResult>}\n   *   The processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youre using a compiler that doesnt serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@linkcode CompileResultMap}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  processSync(file) {\n    /** @type {boolean} */\n    let complete = false\n    /** @type {VFileWithOutput<CompileResult> | undefined} */\n    let result\n\n    this.freeze()\n    assertParser('processSync', this.parser || this.Parser)\n    assertCompiler('processSync', this.compiler || this.Compiler)\n\n    this.process(file, realDone)\n    assertDone('processSync', 'process', complete)\n    assert(result, 'we either bailed on an error or have a tree')\n\n    return result\n\n    /**\n     * @type {ProcessCallback<VFileWithOutput<CompileResult>>}\n     */\n    function realDone(error, file) {\n      complete = true\n      bail(error)\n      result = file\n    }\n  }\n\n  /**\n   * Run *transformers* on a syntax tree.\n   *\n   * > **Note**: `run` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `run` performs the run phase, not other phases.\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} file\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {(\n   *   RunCallback<TailTree extends undefined ? Node : TailTree> |\n   *   Compatible\n   * )} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]\n   *   Callback (optional).\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise, a promise rejected with a fatal error or resolved with the\n   *   transformed tree.\n   */\n  run(tree, file, done) {\n    assertNode(tree)\n    this.freeze()\n\n    const transformers = this.transformers\n\n    if (!done && typeof file === 'function') {\n      done = file\n      file = undefined\n    }\n\n    return done ? executor(undefined, done) : new Promise(executor)\n\n    // Note: `void`s needed for TS.\n    /**\n     * @param {(\n     *   ((tree: TailTree extends undefined ? Node : TailTree) => undefined | void) |\n     *   undefined\n     * )} resolve\n     * @param {(error: Error) => undefined | void} reject\n     * @returns {undefined}\n     */\n    function executor(resolve, reject) {\n      assert(\n        typeof file !== 'function',\n        '`file` cant be a `done` anymore, we checked'\n      )\n      const realFile = vfile(file)\n      transformers.run(tree, realFile, realDone)\n\n      /**\n       * @param {Error | undefined} error\n       * @param {Node} outputTree\n       * @param {VFile} file\n       * @returns {undefined}\n       */\n      function realDone(error, outputTree, file) {\n        const resultingTree =\n          /** @type {TailTree extends undefined ? Node : TailTree} */ (\n            outputTree || tree\n          )\n\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(resultingTree)\n        } else {\n          assert(done, '`done` is defined if `resolve` is not')\n          done(undefined, resultingTree, file)\n        }\n      }\n    }\n  }\n\n  /**\n   * Run *transformers* on a syntax tree.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > **Note**: `runSync` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `runSync` performs the run phase, not other phases.\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {TailTree extends undefined ? Node : TailTree}\n   *   Transformed tree.\n   */\n  runSync(tree, file) {\n    /** @type {boolean} */\n    let complete = false\n    /** @type {(TailTree extends undefined ? Node : TailTree) | undefined} */\n    let result\n\n    this.run(tree, file, realDone)\n\n    assertDone('runSync', 'run', complete)\n    assert(result, 'we either bailed on an error or have a tree')\n    return result\n\n    /**\n     * @type {RunCallback<TailTree extends undefined ? Node : TailTree>}\n     */\n    function realDone(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * Compile a syntax tree.\n   *\n   * > **Note**: `stringify` freezes the processor if not already *frozen*.\n   *\n   * > **Note**: `stringify` performs the stringify phase, not the run phase\n   * > or other phases.\n   *\n   * @param {CompileTree extends undefined ? Node : CompileTree} tree\n   *   Tree to compile.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {CompileResult extends undefined ? Value : CompileResult}\n   *   Textual representation of the tree (see note).\n   *\n   *   > **Note**: unified typically compiles by serializing: most compilers\n   *   > return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youre using a compiler that doesnt serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@linkcode CompileResultMap}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  stringify(tree, file) {\n    this.freeze()\n    const realFile = vfile(file)\n    const compiler = this.compiler || this.Compiler\n    assertCompiler('stringify', compiler)\n    assertNode(tree)\n\n    return compiler(tree, realFile)\n  }\n\n  /**\n   * Configure the processor to use a plugin, a list of usable values, or a\n   * preset.\n   *\n   * If the processor is already using a plugin, the previous plugin\n   * configuration is changed based on the options that are passed in.\n   * In other words, the plugin is not added a second time.\n   *\n   * > **Note**: `use` cannot be called on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * @example\n   *   There are many ways to pass plugins to `.use()`.\n   *   This example gives an overview:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   unified()\n   *     // Plugin with options:\n   *     .use(pluginA, {x: true, y: true})\n   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n   *     .use(pluginA, {y: false, z: true})\n   *     // Plugins:\n   *     .use([pluginB, pluginC])\n   *     // Two plugins, the second with options:\n   *     .use([pluginD, [pluginE, {}]])\n   *     // Preset with plugins and settings:\n   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n   *     // Settings only:\n   *     .use({settings: {position: false}})\n   *   ```\n   *\n   * @template {Array<unknown>} [Parameters=[]]\n   * @template {Node | string | undefined} [Input=undefined]\n   * @template [Output=Input]\n   *\n   * @overload\n   * @param {Preset | null | undefined} [preset]\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {PluggableList} list\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Plugin<Parameters, Input, Output>} plugin\n   * @param {...(Parameters | [boolean])} parameters\n   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}\n   *\n   * @param {PluggableList | Plugin | Preset | null | undefined} value\n   *   Usable value.\n   * @param {...unknown} parameters\n   *   Parameters, when a plugin is given as a usable value.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   Current processor.\n   */\n  use(value, ...parameters) {\n    const attachers = this.attachers\n    const namespace = this.namespace\n\n    assertUnfrozen('use', this.frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, parameters)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    return this\n\n    /**\n     * @param {Pluggable} value\n     * @returns {undefined}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value, [])\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...parameters] =\n            /** @type {PluginTuple<Array<unknown>>} */ (value)\n          addPlugin(plugin, parameters)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {undefined}\n     */\n    function addPreset(result) {\n      if (!('plugins' in result) && !('settings' in result)) {\n        throw new Error(\n          'Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither'\n        )\n      }\n\n      addList(result.plugins)\n\n      if (result.settings) {\n        namespace.settings = extend(true, namespace.settings, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList | null | undefined} plugins\n     * @returns {undefined}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {Array<unknown>} parameters\n     * @returns {undefined}\n     */\n    function addPlugin(plugin, parameters) {\n      let index = -1\n      let entryIndex = -1\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entryIndex = index\n          break\n        }\n      }\n\n      if (entryIndex === -1) {\n        attachers.push([plugin, ...parameters])\n      }\n      // Only set if there was at least a `primary` value, otherwise wed change\n      // `arguments.length`.\n      else if (parameters.length > 0) {\n        let [primary, ...rest] = parameters\n        const currentPrimary = attachers[entryIndex][1]\n        if (isPlainObj(currentPrimary) && isPlainObj(primary)) {\n          primary = extend(true, currentPrimary, primary)\n        }\n\n        attachers[entryIndex] = [plugin, primary, ...rest]\n      }\n    }\n  }\n}\n\n// Note: this returns a *callable* instance.\n// Thats why its documented as a function.\n/**\n * Create a new processor.\n *\n * @example\n *   This example shows how a new processor can be created (from `remark`) and linked\n *   to **stdin**(4) and **stdout**(4).\n *\n *   ```js\n *   import process from 'node:process'\n *   import concatStream from 'concat-stream'\n *   import {remark} from 'remark'\n *\n *   process.stdin.pipe(\n *     concatStream(function (buf) {\n *       process.stdout.write(String(remark().processSync(buf)))\n *     })\n *   )\n *   ```\n *\n * @returns\n *   New *unfrozen* processor (`processor`).\n *\n *   This processor is configured to work the same as its ancestor.\n *   When the descendant processor is configured in the future it does not\n *   affect the ancestral processor.\n */\nexport const unified = new Processor().freeze()\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is Value}\n */\nfunction looksLikeAValue(value) {\n  return typeof value === 'string' || isUint8Array(value)\n}\n\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */\nfunction isUint8Array(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'byteLength' in value &&\n      'byteOffset' in value\n  )\n}\n","/**\n * @import {Element, ElementContent, Nodes, Parents, Root} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {ComponentProps, ElementType, ReactElement} from 'react'\n * @import {Options as RemarkRehypeOptions} from 'remark-rehype'\n * @import {BuildVisitor} from 'unist-util-visit'\n * @import {PluggableList, Processor} from 'unified'\n */\n\n/**\n * @callback AllowElement\n *   Filter elements.\n * @param {Readonly<Element>} element\n *   Element to check.\n * @param {number} index\n *   Index of `element` in `parent`.\n * @param {Readonly<Parents> | undefined} parent\n *   Parent of `element`.\n * @returns {boolean | null | undefined}\n *   Whether to allow `element` (default: `false`).\n */\n\n/**\n * @typedef ExtraProps\n *   Extra fields we pass.\n * @property {Element | undefined} [node]\n *   passed when `passNode` is on.\n */\n\n/**\n * @typedef {{\n *   [Key in Extract<ElementType, string>]?: ElementType<ComponentProps<Key> & ExtraProps>\n * }} Components\n *   Map tag names to components.\n */\n\n/**\n * @typedef Deprecation\n *   Deprecation.\n * @property {string} from\n *   Old field.\n * @property {string} id\n *   ID in readme.\n * @property {keyof Options} [to]\n *   New field.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {AllowElement | null | undefined} [allowElement]\n *   Filter elements (optional);\n *   `allowedElements` / `disallowedElements` is used first.\n * @property {ReadonlyArray<string> | null | undefined} [allowedElements]\n *   Tag names to allow (default: all tag names);\n *   cannot combine w/ `disallowedElements`.\n * @property {string | null | undefined} [children]\n *   Markdown.\n * @property {string | null | undefined} [className]\n *   Wrap in a `div` with this class name.\n * @property {Components | null | undefined} [components]\n *   Map tag names to components.\n * @property {ReadonlyArray<string> | null | undefined} [disallowedElements]\n *   Tag names to disallow (default: `[]`);\n *   cannot combine w/ `allowedElements`.\n * @property {PluggableList | null | undefined} [rehypePlugins]\n *   List of rehype plugins to use.\n * @property {PluggableList | null | undefined} [remarkPlugins]\n *   List of remark plugins to use.\n * @property {Readonly<RemarkRehypeOptions> | null | undefined} [remarkRehypeOptions]\n *   Options to pass through to `remark-rehype`.\n * @property {boolean | null | undefined} [skipHtml=false]\n *   Ignore HTML in markdown completely (default: `false`).\n * @property {boolean | null | undefined} [unwrapDisallowed=false]\n *   Extract (unwrap) whats in disallowed elements (default: `false`);\n *   normally when say `strong` is not allowed, it and its children are dropped,\n *   with `unwrapDisallowed` the element itself is replaced by its children.\n * @property {UrlTransform | null | undefined} [urlTransform]\n *   Change URLs (default: `defaultUrlTransform`)\n */\n\n/**\n * @callback UrlTransform\n *   Transform all URLs.\n * @param {string} url\n *   URL.\n * @param {string} key\n *   Property name (example: `'href'`).\n * @param {Readonly<Element>} node\n *   Node.\n * @returns {string | null | undefined}\n *   Transformed URL (optional).\n */\n\nimport {unreachable} from 'devlop'\nimport {toJsxRuntime} from 'hast-util-to-jsx-runtime'\nimport {urlAttributes} from 'html-url-attributes'\nimport {Fragment, jsx, jsxs} from 'react/jsx-runtime'\nimport {createElement, useEffect, useState} from 'react'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport {unified} from 'unified'\nimport {visit} from 'unist-util-visit'\nimport {VFile} from 'vfile'\n\nconst changelog =\n  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md'\n\n/** @type {PluggableList} */\nconst emptyPlugins = []\n/** @type {Readonly<RemarkRehypeOptions>} */\nconst emptyRemarkRehypeOptions = {allowDangerousHtml: true}\nconst safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i\n\n// Mutable because we `delete` any time its used and a message is sent.\n/** @type {ReadonlyArray<Readonly<Deprecation>>} */\nconst deprecations = [\n  {from: 'astPlugins', id: 'remove-buggy-html-in-markdown-parser'},\n  {from: 'allowDangerousHtml', id: 'remove-buggy-html-in-markdown-parser'},\n  {\n    from: 'allowNode',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'allowElement'\n  },\n  {\n    from: 'allowedTypes',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'allowedElements'\n  },\n  {\n    from: 'disallowedTypes',\n    id: 'replace-allownode-allowedtypes-and-disallowedtypes',\n    to: 'disallowedElements'\n  },\n  {from: 'escapeHtml', id: 'remove-buggy-html-in-markdown-parser'},\n  {from: 'includeElementIndex', id: '#remove-includeelementindex'},\n  {\n    from: 'includeNodeIndex',\n    id: 'change-includenodeindex-to-includeelementindex'\n  },\n  {from: 'linkTarget', id: 'remove-linktarget'},\n  {from: 'plugins', id: 'change-plugins-to-remarkplugins', to: 'remarkPlugins'},\n  {from: 'rawSourcePos', id: '#remove-rawsourcepos'},\n  {from: 'renderers', id: 'change-renderers-to-components', to: 'components'},\n  {from: 'source', id: 'change-source-to-children', to: 'children'},\n  {from: 'sourcePos', id: '#remove-sourcepos'},\n  {from: 'transformImageUri', id: '#add-urltransform', to: 'urlTransform'},\n  {from: 'transformLinkUri', id: '#add-urltransform', to: 'urlTransform'}\n]\n\n/**\n * Component to render markdown.\n *\n * This is a synchronous component.\n * When using async plugins,\n * see {@linkcode MarkdownAsync} or {@linkcode MarkdownHooks}.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {ReactElement}\n *   React element.\n */\nexport function Markdown(options) {\n  const processor = createProcessor(options)\n  const file = createFile(options)\n  return post(processor.runSync(processor.parse(file), file), options)\n}\n\n/**\n * Component to render markdown with support for async plugins\n * through async/await.\n *\n * Components returning promises are supported on the server.\n * For async support on the client,\n * see {@linkcode MarkdownHooks}.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {Promise<ReactElement>}\n *   Promise to a React element.\n */\nexport async function MarkdownAsync(options) {\n  const processor = createProcessor(options)\n  const file = createFile(options)\n  const tree = await processor.run(processor.parse(file), file)\n  return post(tree, options)\n}\n\n/**\n * Component to render markdown with support for async plugins through hooks.\n *\n * This uses `useEffect` and `useState` hooks.\n * Hooks run on the client and do not immediately render something.\n * For async support on the server,\n * see {@linkcode MarkdownAsync}.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {ReactElement}\n *   React element.\n */\nexport function MarkdownHooks(options) {\n  const processor = createProcessor(options)\n  const [error, setError] = useState(\n    /** @type {Error | undefined} */ (undefined)\n  )\n  const [tree, setTree] = useState(/** @type {Root | undefined} */ (undefined))\n\n  useEffect(\n    /* c8 ignore next 7 -- hooks are client-only. */\n    function () {\n      const file = createFile(options)\n      processor.run(processor.parse(file), file, function (error, tree) {\n        setError(error)\n        setTree(tree)\n      })\n    },\n    [\n      options.children,\n      options.rehypePlugins,\n      options.remarkPlugins,\n      options.remarkRehypeOptions\n    ]\n  )\n\n  /* c8 ignore next -- hooks are client-only. */\n  if (error) throw error\n\n  /* c8 ignore next -- hooks are client-only. */\n  return tree ? post(tree, options) : createElement(Fragment)\n}\n\n/**\n * Set up the `unified` processor.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {Processor<MdastRoot, MdastRoot, Root, undefined, undefined>}\n *   Result.\n */\nfunction createProcessor(options) {\n  const rehypePlugins = options.rehypePlugins || emptyPlugins\n  const remarkPlugins = options.remarkPlugins || emptyPlugins\n  const remarkRehypeOptions = options.remarkRehypeOptions\n    ? {...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions}\n    : emptyRemarkRehypeOptions\n\n  const processor = unified()\n    .use(remarkParse)\n    .use(remarkPlugins)\n    .use(remarkRehype, remarkRehypeOptions)\n    .use(rehypePlugins)\n\n  return processor\n}\n\n/**\n * Set up the virtual file.\n *\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {VFile}\n *   Result.\n */\nfunction createFile(options) {\n  const children = options.children || ''\n  const file = new VFile()\n\n  if (typeof children === 'string') {\n    file.value = children\n  } else {\n    unreachable(\n      'Unexpected value `' +\n        children +\n        '` for `children` prop, expected `string`'\n    )\n  }\n\n  return file\n}\n\n/**\n * Process the result from unified some more.\n *\n * @param {Nodes} tree\n *   Tree.\n * @param {Readonly<Options>} options\n *   Props.\n * @returns {ReactElement}\n *   React element.\n */\nfunction post(tree, options) {\n  const allowedElements = options.allowedElements\n  const allowElement = options.allowElement\n  const components = options.components\n  const disallowedElements = options.disallowedElements\n  const skipHtml = options.skipHtml\n  const unwrapDisallowed = options.unwrapDisallowed\n  const urlTransform = options.urlTransform || defaultUrlTransform\n\n  for (const deprecation of deprecations) {\n    if (Object.hasOwn(options, deprecation.from)) {\n      unreachable(\n        'Unexpected `' +\n          deprecation.from +\n          '` prop, ' +\n          (deprecation.to\n            ? 'use `' + deprecation.to + '` instead'\n            : 'remove it') +\n          ' (see <' +\n          changelog +\n          '#' +\n          deprecation.id +\n          '> for more info)'\n      )\n    }\n  }\n\n  if (allowedElements && disallowedElements) {\n    unreachable(\n      'Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other'\n    )\n  }\n\n  // Wrap in `div` if theres a class name.\n  if (options.className) {\n    tree = {\n      type: 'element',\n      tagName: 'div',\n      properties: {className: options.className},\n      // Assume no doctypes.\n      children: /** @type {Array<ElementContent>} */ (\n        tree.type === 'root' ? tree.children : [tree]\n      )\n    }\n  }\n\n  visit(tree, transform)\n\n  return toJsxRuntime(tree, {\n    Fragment,\n    // @ts-expect-error\n    // React components are allowed to return numbers,\n    // but not according to the types in hast-util-to-jsx-runtime\n    components,\n    ignoreInvalidStyle: true,\n    jsx,\n    jsxs,\n    passKeys: true,\n    passNode: true\n  })\n\n  /** @type {BuildVisitor<Root>} */\n  function transform(node, index, parent) {\n    if (node.type === 'raw' && parent && typeof index === 'number') {\n      if (skipHtml) {\n        parent.children.splice(index, 1)\n      } else {\n        parent.children[index] = {type: 'text', value: node.value}\n      }\n\n      return index\n    }\n\n    if (node.type === 'element') {\n      /** @type {string} */\n      let key\n\n      for (key in urlAttributes) {\n        if (\n          Object.hasOwn(urlAttributes, key) &&\n          Object.hasOwn(node.properties, key)\n        ) {\n          const value = node.properties[key]\n          const test = urlAttributes[key]\n          if (test === null || test.includes(node.tagName)) {\n            node.properties[key] = urlTransform(String(value || ''), key, node)\n          }\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      let remove = allowedElements\n        ? !allowedElements.includes(node.tagName)\n        : disallowedElements\n          ? disallowedElements.includes(node.tagName)\n          : false\n\n      if (!remove && allowElement && typeof index === 'number') {\n        remove = !allowElement(node, index, parent)\n      }\n\n      if (remove && parent && typeof index === 'number') {\n        if (unwrapDisallowed && node.children) {\n          parent.children.splice(index, 1, ...node.children)\n        } else {\n          parent.children.splice(index, 1)\n        }\n\n        return index\n      }\n    }\n  }\n}\n\n/**\n * Make a URL safe.\n *\n * @satisfies {UrlTransform}\n * @param {string} value\n *   URL.\n * @returns {string}\n *   Safe URL.\n */\nexport function defaultUrlTransform(value) {\n  // Same as:\n  // <https://github.com/micromark/micromark/blob/929275e/packages/micromark-util-sanitize-uri/dev/index.js#L34>\n  // But without the `encode` part.\n  const colon = value.indexOf(':')\n  const questionMark = value.indexOf('?')\n  const numberSign = value.indexOf('#')\n  const slash = value.indexOf('/')\n\n  if (\n    // If there is no protocol, its relative.\n    colon === -1 ||\n    // If the first colon is after a `?`, `#`, or `/`, its not a protocol.\n    (slash !== -1 && colon > slash) ||\n    (questionMark !== -1 && colon > questionMark) ||\n    (numberSign !== -1 && colon > numberSign) ||\n    // It is a protocol, it should be allowed.\n    safeProtocol.test(value.slice(0, colon))\n  ) {\n    return value\n  }\n\n  return ''\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('hast-util-is-element').Test} Test\n */\n\n/**\n * @typedef {'after' | 'append' | 'before' | 'prepend' | 'wrap'} Behavior\n *   Behavior.\n *\n * @callback Build\n *   Generate content.\n * @param {Readonly<Element>} element\n *   Current heading.\n * @returns {Array<ElementContent> | ElementContent}\n *   Content.\n *\n * @callback BuildProperties\n *   Generate properties.\n * @param {Readonly<Element>} element\n *   Current heading.\n * @returns {Properties}\n *   Properties.\n *\n * @typedef Options\n *   Configuration.\n * @property {Behavior | null | undefined} [behavior='prepend']\n *   How to create links (default: `'prepend'`).\n * @property {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build | null | undefined} [content]\n *   Content to insert in the link (default: if `'wrap'` then `undefined`,\n *   otherwise `<span class=\"icon icon-link\"></span>`);\n *   if `behavior` is `'wrap'` and `Build` is passed, its result replaces the\n *   existing content, otherwise the content is added after existing content.\n * @property {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build | null | undefined} [group]\n *   Content to wrap the heading and link with, if `behavior` is `'after'` or\n *   `'before'` (optional).\n * @property {Readonly<Properties> | BuildProperties | null | undefined} [headingProperties]\n *   Extra properties to set on the heading (optional).\n * @property {Readonly<Properties> | BuildProperties | null | undefined} [properties]\n *   Extra properties to set on the link when injecting (default:\n *   `{ariaHidden: true, tabIndex: -1}` if `'append'` or `'prepend'`, otherwise\n *   `undefined`).\n * @property {Test | null | undefined} [test]\n *   Extra test for which headings are linked (optional).\n */\n\n/**\n * @template T\n *   Kind.\n * @typedef {(\n *   T extends Record<any, any>\n *     ? {-readonly [k in keyof T]: Cloneable<T[k]>}\n *     : T\n * )} Cloneable\n *   Deep clone.\n *\n *   See: <https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1237#issuecomment-1345515448>\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {headingRank} from 'hast-util-heading-rank'\nimport {convertElement} from 'hast-util-is-element'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/** @type {Element} */\nconst contentDefaults = {\n  type: 'element',\n  tagName: 'span',\n  properties: {className: ['icon', 'icon-link']},\n  children: []\n}\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Add links from headings back to themselves.\n *\n * ###### Notes\n *\n * This plugin only applies to headings with `id`s.\n * Use `rehype-slug` to generate `id`s for headings that dont have them.\n *\n * Several behaviors are supported:\n *\n * *   `'prepend'` (default)  inject link before the heading text\n * *   `'append'`  inject link after the heading text\n * *   `'wrap'`  wrap the whole heading text with the link\n * *   `'before'`  insert link before the heading\n * *   `'after'`  insert link after the heading\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeAutolinkHeadings(options) {\n  const settings = options || emptyOptions\n  let properties = settings.properties\n  const headingOroperties = settings.headingProperties\n  const behavior = settings.behavior || 'prepend'\n  const content = settings.content\n  const group = settings.group\n  const is = convertElement(settings.test)\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  let method\n\n  if (behavior === 'after' || behavior === 'before') {\n    method = around\n  } else if (behavior === 'wrap') {\n    method = wrap\n  } else {\n    method = inject\n\n    if (!properties) {\n      properties = {ariaHidden: 'true', tabIndex: -1}\n    }\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, 'element', function (node, index, parent) {\n      if (headingRank(node) && node.properties.id && is(node, index, parent)) {\n        Object.assign(node.properties, toProperties(headingOroperties, node))\n        return method(node, index, parent)\n      }\n    })\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function inject(node) {\n    const children = toChildren(content || contentDefaults, node)\n    node.children[behavior === 'prepend' ? 'unshift' : 'push'](\n      create(node, toProperties(properties, node), children)\n    )\n\n    return [SKIP]\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function around(node, index, parent) {\n    /* c8 ignore next -- uncommon */\n    if (typeof index !== 'number' || !parent) return\n\n    const children = toChildren(content || contentDefaults, node)\n    const link = create(node, toProperties(properties, node), children)\n    let nodes = behavior === 'before' ? [link, node] : [node, link]\n\n    if (group) {\n      const grouping = toNode(group, node)\n\n      if (grouping && !Array.isArray(grouping) && grouping.type === 'element') {\n        grouping.children = nodes\n        nodes = [grouping]\n      }\n    }\n\n    parent.children.splice(index, 1, ...nodes)\n\n    return [SKIP, index + nodes.length]\n  }\n\n  /** @type {import('unist-util-visit').Visitor<Element>} */\n  function wrap(node) {\n    /** @type {Array<ElementContent>} */\n    let before = node.children\n    /** @type {Array<ElementContent> | ElementContent} */\n    let after = []\n\n    if (typeof content === 'function') {\n      before = []\n      after = content(node)\n    } else if (content) {\n      after = clone(content)\n    }\n\n    node.children = [\n      create(\n        node,\n        toProperties(properties, node),\n        Array.isArray(after) ? [...before, ...after] : [...before, after]\n      )\n    ]\n\n    return [SKIP]\n  }\n}\n\n/**\n * Deep clone.\n *\n * @template T\n *   Kind.\n * @param {T} thing\n *   Thing to clone.\n * @returns {Cloneable<T>}\n *   Cloned thing.\n */\nfunction clone(thing) {\n  // Cast because its mutable now.\n  return /** @type {Cloneable<T>} */ (structuredClone(thing))\n}\n\n/**\n * Create an `a`.\n *\n * @param {Readonly<Element>} node\n *   Related heading.\n * @param {Properties | undefined} properties\n *   Properties to set on the link.\n * @param {Array<ElementContent>} children\n *   Content.\n * @returns {Element}\n *   Link.\n */\nfunction create(node, properties, children) {\n  return {\n    type: 'element',\n    tagName: 'a',\n    properties: {...properties, href: '#' + node.properties.id},\n    children\n  }\n}\n\n/**\n * Turn into children.\n *\n * @param {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build} value\n *   Content.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Array<ElementContent>}\n *   Children.\n */\nfunction toChildren(value, node) {\n  const result = toNode(value, node)\n  return Array.isArray(result) ? result : [result]\n}\n\n/**\n * Turn into a node.\n *\n * @param {Readonly<ElementContent> | ReadonlyArray<ElementContent> | Build} value\n *   Content.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Array<ElementContent> | ElementContent}\n *   Node.\n */\nfunction toNode(value, node) {\n  if (typeof value === 'function') return value(node)\n  return clone(value)\n}\n\n/**\n * Turn into properties.\n *\n * @param {Readonly<Properties> | BuildProperties | null | undefined} value\n *   Properties.\n * @param {Readonly<Element>} node\n *   Related heading.\n * @returns {Properties}\n *   Properties.\n */\nfunction toProperties(value, node) {\n  if (typeof value === 'function') return value(node)\n  return value ? clone(value) : {}\n}\n","/**\n * @import {ElementContent, Root} from 'hast'\n * @import {KatexOptions} from 'katex'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @typedef {Omit<KatexOptions, 'displayMode' | 'throwOnError'>} Options\n */\n\nimport {fromHtmlIsomorphic} from 'hast-util-from-html-isomorphic'\nimport {toText} from 'hast-util-to-text'\nimport katex from 'katex'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n/** @type {ReadonlyArray<unknown>} */\nconst emptyClasses = []\n\n/**\n * Render elements with a `language-math` (or `math-display`, `math-inline`)\n * class with KaTeX.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeKatex(options) {\n  const settings = options || emptyOptions\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    visitParents(tree, 'element', function (element, parents) {\n      const classes = Array.isArray(element.properties.className)\n        ? element.properties.className\n        : emptyClasses\n      // This class can be generated from markdown with ` ```math `.\n      const languageMath = classes.includes('language-math')\n      // This class is used by `remark-math` for flow math (block, `$$\\nmath\\n$$`).\n      const mathDisplay = classes.includes('math-display')\n      // This class is used by `remark-math` for text math (inline, `$math$`).\n      const mathInline = classes.includes('math-inline')\n      let displayMode = mathDisplay\n\n      // Any class is fine.\n      if (!languageMath && !mathDisplay && !mathInline) {\n        return\n      }\n\n      let parent = parents[parents.length - 1]\n      let scope = element\n\n      // If this was generated with ` ```math `, replace the `<pre>` and use\n      // display.\n      if (\n        element.tagName === 'code' &&\n        languageMath &&\n        parent &&\n        parent.type === 'element' &&\n        parent.tagName === 'pre'\n      ) {\n        scope = parent\n        parent = parents[parents.length - 2]\n        displayMode = true\n      }\n\n      /* c8 ignore next -- verbose to test. */\n      if (!parent) return\n\n      const value = toText(scope, {whitespace: 'pre'})\n\n      /** @type {Array<ElementContent> | string | undefined} */\n      let result\n\n      try {\n        result = katex.renderToString(value, {\n          ...settings,\n          displayMode,\n          throwOnError: true\n        })\n      } catch (error) {\n        const cause = /** @type {Error} */ (error)\n        const ruleId = cause.name.toLowerCase()\n\n        file.message('Could not render math with KaTeX', {\n          ancestors: [...parents, element],\n          cause,\n          place: element.position,\n          ruleId,\n          source: 'rehype-katex'\n        })\n\n        // KaTeX *should* handle `ParseError` itself, but not others.\n        // it doesnt always:\n        // <https://github.com/remarkjs/react-markdown/issues/853>\n        try {\n          result = katex.renderToString(value, {\n            ...settings,\n            displayMode,\n            strict: 'ignore',\n            throwOnError: false\n          })\n        } catch {\n          // Generate similar markup if this is an other error.\n          // See: <https://github.com/KaTeX/KaTeX/blob/5dc7af0/docs/error.md>.\n          result = [\n            {\n              type: 'element',\n              tagName: 'span',\n              properties: {\n                className: ['katex-error'],\n                style: 'color:' + (settings.errorColor || '#cc0000'),\n                title: String(error)\n              },\n              children: [{type: 'text', value}]\n            }\n          ]\n        }\n      }\n\n      if (typeof result === 'string') {\n        const root = fromHtmlIsomorphic(result, {fragment: true})\n        // Cast as we dont expect `doctypes` in KaTeX result.\n        result = /** @type {Array<ElementContent>} */ (root.children)\n      }\n\n      const index = parent.children.indexOf(scope)\n      parent.children.splice(index, 1, ...result)\n      return SKIP\n    })\n  }\n}\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast-util-raw').Options} RawOptions\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {Omit<RawOptions, 'file'>} Options\n *   Configuration.\n */\n\nimport {raw} from 'hast-util-raw'\n\n/**\n * Parse the tree (and raw nodes) again, keeping positional info okay.\n *\n * @param {Options | null | undefined}  [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeRaw(options) {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {Root}\n   *   New tree.\n   */\n  return function (tree, file) {\n    // Assume root in -> root out.\n    const result = /** @type {Root} */ (raw(tree, {...options, file}))\n    return result\n  }\n}\n","/**\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {string} [prefix='']\n *   Prefix to add in front of `id`s (default: `''`).\n */\n\nimport GithubSlugger from 'github-slugger'\nimport {headingRank} from 'hast-util-heading-rank'\nimport {toString} from 'hast-util-to-string'\nimport {visit} from 'unist-util-visit'\n\n/** @type {Options} */\nconst emptyOptions = {}\nconst slugs = new GithubSlugger()\n\n/**\n * Add `id`s to headings.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeSlug(options) {\n  const settings = options || emptyOptions\n  const prefix = settings.prefix || ''\n\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    slugs.reset()\n\n    visit(tree, 'element', function (node) {\n      if (headingRank(node) && !node.properties.id) {\n        node.properties.id = prefix + slugs.slug(toString(node))\n      }\n    })\n  }\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nexport function findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = convert(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, 'text', visitor)\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasnt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n","/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\nimport {ccount} from 'ccount'\nimport {ok as assert} from 'devlop'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nexport function gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    // If its an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n","/**\n * @import {\n *   CompileContext,\n *   Extension as FromMarkdownExtension,\n *   Handle as FromMarkdownHandle\n * } from 'mdast-util-from-markdown'\n * @import {ToMarkdownOptions} from 'mdast-util-gfm-footnote'\n * @import {\n *   Handle as ToMarkdownHandle,\n *   Map,\n *   Options as ToMarkdownExtension\n * } from 'mdast-util-to-markdown'\n * @import {FootnoteDefinition, FootnoteReference} from 'mdast'\n */\n\nimport {ok as assert} from 'devlop'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'footnoteReference')\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'footnoteDefinition')\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[^')\n  const exit = state.enter('footnoteReference')\n  const subexit = state.enter('reference')\n  value += tracker.move(\n    state.safe(state.associationId(node), {after: ']', before: value})\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteCallString: enterFootnoteCallString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: enterFootnoteDefinition\n    },\n    exit: {\n      gfmFootnoteCallString: exitFootnoteCallString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: exitFootnoteDefinition\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown(options) {\n  // To do: next major: change default.\n  let firstLineBlank = false\n\n  if (options && options.firstLineBlank) {\n    firstLineBlank = true\n  }\n\n  return {\n    handlers: {footnoteDefinition, footnoteReference},\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['label', 'phrasing', 'reference']}]\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteDefinition} node\n   */\n  function footnoteDefinition(node, _, state, info) {\n    const tracker = state.createTracker(info)\n    let value = tracker.move('[^')\n    const exit = state.enter('footnoteDefinition')\n    const subexit = state.enter('label')\n    value += tracker.move(\n      state.safe(state.associationId(node), {before: value, after: ']'})\n    )\n    subexit()\n\n    value += tracker.move(']:')\n\n    if (node.children && node.children.length > 0) {\n      tracker.shift(4)\n\n      value += tracker.move(\n        (firstLineBlank ? '\\n' : ' ') +\n          state.indentLines(\n            state.containerFlow(node, tracker.current()),\n            firstLineBlank ? mapAll : mapExceptFirst\n          )\n      )\n    }\n\n    exit()\n\n    return value\n  }\n}\n\n/** @type {Map} */\nfunction mapExceptFirst(line, index, blank) {\n  return index === 0 ? line : mapAll(line, index, blank)\n}\n\n/** @type {Map} */\nfunction mapAll(line, index, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nexport function gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * @import {Blockquote, Parents} from 'mdast'\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @import {Break, Parents} from 'mdast'\n * @import {Info, State} from 'mdast-util-to-markdown'\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Code} from 'mdast'\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {Code, Parents} from 'mdast'\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Definition, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nexport function encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @import {EncodeSides} from '../types.js'\n */\n\nimport {classifyCharacter} from 'micromark-util-classify-character'\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nexport function encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside)\n  const insideKind = classifyCharacter(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Heading} from 'mdast'\n */\n\nimport {EXIT, visit} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Heading, Parents} from 'mdast'\n */\n\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {List, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : checkBulletOther(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {ListItem, Parents} from 'mdast'\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Paragraph, Parents} from 'mdast'\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n","/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * >  **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nexport const phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    convert([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Root} from 'mdast'\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return phrasing(d)\n  })\n\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return container.call(state, node, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\nimport {checkStrong} from '../util/check-strong.js'\nimport {encodeCharacterReference} from '../util/encode-character-reference.js'\nimport {encodeInfo} from '../util/encode-info.js'\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n","/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Text} from 'mdast'\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n","/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Parents, ThematicBreak} from 'mdast'\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').TableRow} TableRow\n *\n * @typedef {import('markdown-table').Options} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').State} State\n * @typedef {import('mdast-util-to-markdown').Info} Info\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells (default:\n *   `true`).\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters (default: `true`).\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells (optional).\n */\n\nimport {ok as assert} from 'devlop'\nimport {markdownTable} from 'markdown-table'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM tables in\n * markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM tables.\n */\nexport function gfmTableFromMarkdown() {\n  return {\n    enter: {\n      table: enterTable,\n      tableData: enterCell,\n      tableHeader: enterCell,\n      tableRow: enterRow\n    },\n    exit: {\n      codeText: exitCodeText,\n      table: exitTable,\n      tableData: exit,\n      tableHeader: exit,\n      tableRow: exit\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  const align = token._align\n  assert(align, 'expected `_align` on table')\n  this.enter(\n    {\n      type: 'table',\n      align: align.map(function (d) {\n        return d === 'none' ? null : d\n      }),\n      children: []\n    },\n    token\n  )\n  this.data.inTable = true\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.data.inTable = undefined\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.data.inTable) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = this.stack[this.stack.length - 1]\n  assert(node.type === 'inlineCode')\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      inlineCode: inlineCodeWithTable,\n      table: handleTable,\n      tableCell: handleTableCell,\n      tableRow: handleTableRow\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, state, info) {\n    return serializeData(handleTableAsData(node, state, info), node.align)\n  }\n\n  /**\n   * This function isnt really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, state, info) {\n    const row = handleTableRowAsData(node, state, info)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, state, info) {\n    const exit = state.enter('tableCell')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...info,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = state.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(children[index], state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableRowAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = state.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(children[index], node, state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, state) {\n    let value = defaultHandlers.inlineCode(node, parent, state)\n\n    if (state.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {ok as assert} from 'devlop'\nimport {defaultHandlers} from 'mdast-util-to-markdown'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nexport function gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  assert(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = defaultHandlers.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @import {Extension as FromMarkdownExtension} from 'mdast-util-from-markdown'\n * @import {Options} from 'mdast-util-gfm'\n * @import {Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown(),\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown(),\n    gfmTableFromMarkdown(),\n    gfmTaskListItemFromMarkdown()\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown(),\n      gfmFootnoteToMarkdown(options),\n      gfmStrikethroughToMarkdown(),\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown()\n    ]\n  }\n}\n","/**\n * @import {Root} from 'mdast'\n * @import {Options} from 'remark-gfm'\n * @import {} from 'remark-parse'\n * @import {} from 'remark-stringify'\n * @import {Processor} from 'unified'\n */\n\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\nimport {gfm} from 'micromark-extension-gfm'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Add support GFM (autolink literals, footnotes, strikethrough, tables,\n * tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkGfm(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor<Root>} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push(gfm(settings))\n  fromMarkdownExtensions.push(gfmFromMarkdown())\n  toMarkdownExtensions.push(gfmToMarkdown(settings))\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with normal dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport {ok as assert} from 'devlop'\nimport {longestStreak} from 'longest-streak'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    assert(code.type === 'element')\n    assert(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    assert(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs dont count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We cant escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/// <reference types=\"mdast-util-math\" />\n/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\nimport {math} from 'micromark-extension-math'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Add support for math.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkMath(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push(math(settings))\n  fromMarkdownExtensions.push(mathFromMarkdown())\n  toMarkdownExtensions.push(mathToMarkdown(settings))\n}\n","/**\n * @import {LinkReference, Link, Paragraph, Root} from 'mdast'\n */\n\nimport {whitespace} from 'hast-util-whitespace'\nimport {SKIP, visit} from 'unist-util-visit'\n\nconst unknown = 1\nconst containsImage = 2\nconst containsOther = 3\n\n/**\n * Remove the wrapping paragraph for images.\n *\n * @returns\n *   Transform.\n */\nexport default function remarkUnwrapImages() {\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    visit(tree, 'paragraph', function (node, index, parent) {\n      if (\n        parent &&\n        typeof index === 'number' &&\n        applicable(node, false) === containsImage\n      ) {\n        parent.children.splice(index, 1, ...node.children)\n        return [SKIP, index]\n      }\n    })\n  }\n}\n\n/**\n * Check if a node can be unraveled.\n *\n * @param {Link | LinkReference | Paragraph} node\n *   Node.\n * @param {boolean} inLink\n *   Whether the node is in a link.\n * @returns {1 | 2 | 3}\n *   Info.\n */\nfunction applicable(node, inLink) {\n  /** @type {1 | 2 | 3} */\n  let image = unknown\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'text' && whitespace(child.value)) {\n      // Whitespace is fine.\n    } else if (child.type === 'image' || child.type === 'imageReference') {\n      image = containsImage\n    } else if (\n      !inLink &&\n      (child.type === 'link' || child.type === 'linkReference')\n    ) {\n      const linkResult = applicable(child, true)\n\n      if (linkResult === containsOther) {\n        return containsOther\n      }\n\n      if (linkResult === containsImage) {\n        image = containsImage\n      }\n    } else {\n      return containsOther\n    }\n  }\n\n  return image\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is a node.\n * @param {unknown} this\n *   The given context.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n *\n * @typedef {Record<string, unknown> | Node} Props\n *   Object to check for equivalence.\n *\n *   Note: `Node` is included as it is common but is not indexable.\n *\n * @typedef {Array<Props | TestFunction | string> | Props | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary node.\n *\n * @callback TestFunction\n *   Check if a node passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | undefined} [index]\n *   The nodes position in its parent.\n * @param {Parent | undefined} [parent]\n *   The nodes parent.\n * @returns {boolean | undefined | void}\n *   Whether this node passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param {unknown} node\n *   Thing to check, typically `Node`.\n * @param {Test} test\n *   A check for a specific node.\n * @param {number | null | undefined} index\n *   The nodes position in its parent.\n * @param {Parent | null | undefined} parent\n *   The nodes parent.\n * @param {unknown} context\n *   Context object (`this`) to pass to `test` functions.\n * @returns {boolean}\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((node?: null | undefined) => false) &\n   *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return looksLikeANode(node)\n        ? check.call(context, node, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param {Test} test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns {Check}\n *   An assertion.\n */\nexport const convert =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return ok\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<Props | TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {Check}\n */\nfunction propsFactory(check) {\n  const checkAsRecord = /** @type {Record<string, unknown>} */ (check)\n\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    const nodeAsRecord = /** @type {Record<string, unknown>} */ (\n      /** @type {unknown} */ (node)\n    )\n\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Node}\n */\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === 'object' && 'type' in value\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Get the ending point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointEnd = point('end')\n\n/**\n * Get the starting point of `node`.\n *\n * @param node\n *   Node.\n * @returns\n *   Point.\n */\nexport const pointStart = point('start')\n\n/**\n * Get the positional info of `node`.\n *\n * @param {'end' | 'start'} type\n *   Side.\n * @returns\n *   Getter.\n */\nfunction point(type) {\n  return point\n\n  /**\n   * Get the point info of `node` at a bound side.\n   *\n   * @param {Node | NodeLike | null | undefined} [node]\n   * @returns {Point | undefined}\n   */\n  function point(node) {\n    const point = (node && node.position && node.position[type]) || {}\n\n    if (\n      typeof point.line === 'number' &&\n      point.line > 0 &&\n      typeof point.column === 'number' &&\n      point.column > 0\n    ) {\n      return {\n        line: point.line,\n        column: point.column,\n        offset:\n          typeof point.offset === 'number' && point.offset > -1\n            ? point.offset\n            : undefined\n      }\n    }\n  }\n}\n\n/**\n * Get the positional info of `node`.\n *\n * @param {Node | NodeLike | null | undefined} [node]\n *   Node.\n * @returns {Position | undefined}\n *   Position.\n */\nexport function position(node) {\n  const start = pointStart(node)\n  const end = pointEnd(node)\n\n  if (start && end) {\n    return {start, end}\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Point | PointLike | Position | PositionLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {InternalAncestor<InclusiveDescendant<Tree>, Child>} Ancestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {'skip' | boolean} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<VisitedParents>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [VisitedParents=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Matches<InclusiveDescendant<Tree>, Check>, Ancestor<Tree, Matches<InclusiveDescendant<Tree>, Check>>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Tree type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from 'unist-util-visit-parents/do-not-use-color'\n\n/** @type {Readonly<ActionTuple>} */\nconst empty = []\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this nodes children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} test\n *   `unist-util-is`-compatible test\n * @param {Visitor | boolean | null | undefined} [visitor]\n *   Handle each node.\n * @param {boolean | null | undefined} [reverse]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visitParents(tree, test, visitor, reverse) {\n  /** @type {Test} */\n  let check\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test\n  } else {\n    // @ts-expect-error visitor given, so `test` isnt a visitor.\n    check = test\n  }\n\n  const is = convert(check)\n  const step = reverse ? -1 : 1\n\n  factory(tree, undefined, [])()\n\n  /**\n   * @param {UnistNode} node\n   * @param {number | undefined} index\n   * @param {Array<UnistParent>} parents\n   */\n  function factory(node, index, parents) {\n    const value = /** @type {Record<string, unknown>} */ (\n      node && typeof node === 'object' ? node : {}\n    )\n\n    if (typeof value.type === 'string') {\n      const name =\n        // `hast`\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : // `xast`\n          typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      Object.defineProperty(visit, 'name', {\n        value:\n          'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n      })\n    }\n\n    return visit\n\n    function visit() {\n      /** @type {Readonly<ActionTuple>} */\n      let result = empty\n      /** @type {Readonly<ActionTuple>} */\n      let subresult\n      /** @type {number} */\n      let offset\n      /** @type {Array<UnistParent>} */\n      let grandparents\n\n      if (!test || is(node, index, parents[parents.length - 1] || undefined)) {\n        // @ts-expect-error: `visitor` is now a visitor.\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if ('children' in node && node.children) {\n        const nodeAsParent = /** @type {UnistParent} */ (node)\n\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step\n          grandparents = parents.concat(nodeAsParent)\n\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset]\n\n            subresult = factory(child, offset, grandparents)()\n\n            if (subresult[0] === EXIT) {\n              return subresult\n            }\n\n            offset =\n              typeof subresult[1] === 'number' ? subresult[1] : offset + step\n          }\n        }\n      }\n\n      return result\n    }\n  }\n}\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {Readonly<ActionTuple>}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return value === null || value === undefined ? empty : [value]\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n// To do: use types from `unist-util-visit-parents` when its released.\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10} Uint\n *   Number; capped reasonably.\n */\n\n/**\n * @typedef {I extends 0 ? 1 : I extends 1 ? 2 : I extends 2 ? 3 : I extends 3 ? 4 : I extends 4 ? 5 : I extends 5 ? 6 : I extends 6 ? 7 : I extends 7 ? 8 : I extends 8 ? 9 : 10} Increment\n *   Increment a number in the type system.\n * @template {Uint} [I=0]\n *   Index.\n */\n\n/**\n * @typedef {(\n *   Node extends UnistParent\n *   ? Node extends {children: Array<infer Children>}\n *     ? Child extends Children ? Node : never\n *     : never\n *   : never\n * )} InternalParent\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {InternalParent<InclusiveDescendant<Tree>, Child>} Parent\n *   Collect nodes in `Tree` that can be parents of `Child`.\n * @template {UnistNode} Tree\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n */\n\n/**\n * @typedef {(\n *   Depth extends Max\n *   ? never\n *   :\n *     | InternalParent<Node, Child>\n *     | InternalAncestor<Node, InternalParent<Node, Child>, Max, Increment<Depth>>\n * )} InternalAncestor\n *   Collect nodes in `Tree` that can be ancestors of `Child`.\n * @template {UnistNode} Node\n *   All node types in a tree.\n * @template {UnistNode} Child\n *   Node to search for.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @typedef {(\n *   Tree extends UnistParent\n *     ? Depth extends Max\n *       ? Tree\n *       : Tree | InclusiveDescendant<Tree['children'][number], Max, Increment<Depth>>\n *     : Tree\n * )} InclusiveDescendant\n *   Collect all (inclusive) descendants of `Tree`.\n *\n *   >  **Note**: for performance reasons, this seems to be the fastest way to\n *   > recurse without actually running into an infinite loop, which the\n *   > previous version did.\n *   >\n *   > Practically, a max of `2` is typically enough assuming a `Root` is\n *   > passed, but it doesnt improve performance.\n *   > It gets higher with `List > ListItem > Table > TableRow > TableCell`.\n *   > Using up to `10` doesnt hurt or help either.\n * @template {UnistNode} Tree\n *   Tree type.\n * @template {Uint} [Max=10]\n *   Max; searches up to this depth.\n * @template {Uint} [Depth=0]\n *   Current depth.\n */\n\n/**\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends UnistNode ? number | undefined : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends UnistParent ? Ancestor | undefined : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n * @template {UnistNode} [Visited=UnistNode]\n *   Visited node type.\n * @template {UnistParent} [Ancestor=UnistParent]\n *   Ancestor type.\n */\n\n/**\n * @typedef {Visitor<Visited, Parent<Ancestor, Visited>>} BuildVisitorFromMatch\n *   Build a typed `Visitor` function from a node and all possible parents.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Visited\n *   Node type.\n * @template {UnistParent} Ancestor\n *   Parent type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     Matches<Descendant, Check>,\n *     Extract<Descendant, UnistParent>\n *   >\n * )} BuildVisitorFromDescendants\n *   Build a typed `Visitor` function from a list of descendants and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n */\n\n/**\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parent`.\n * @template {UnistNode} [Tree=UnistNode]\n *   Node type.\n * @template {Test} [Check=Test]\n *   Test type.\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} check\n * @param {BuildVisitor<Tree, Check>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @overload\n * @param {Tree} tree\n * @param {BuildVisitor<Tree>} visitor\n * @param {boolean | null | undefined} [reverse]\n * @returns {undefined}\n *\n * @param {UnistNode} tree\n *   Tree to traverse.\n * @param {Visitor | Test} testOrVisitor\n *   `unist-util-is`-compatible test (optional, omit to pass a visitor).\n * @param {Visitor | boolean | null | undefined} [visitorOrReverse]\n *   Handle each node (when test is omitted, pass `reverse`).\n * @param {boolean | null | undefined} [maybeReverse=false]\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns {undefined}\n *   Nothing.\n *\n * @template {UnistNode} Tree\n *   Node type.\n * @template {Test} Check\n *   `unist-util-is`-compatible test.\n */\nexport function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  /** @type {boolean | null | undefined} */\n  let reverse\n  /** @type {Test} */\n  let test\n  /** @type {Visitor} */\n  let visitor\n\n  if (\n    typeof testOrVisitor === 'function' &&\n    typeof visitorOrReverse !== 'function'\n  ) {\n    test = undefined\n    visitor = testOrVisitor\n    reverse = visitorOrReverse\n  } else {\n    // @ts-expect-error: assume the overload with test was given.\n    test = testOrVisitor\n    // @ts-expect-error: assume the overload with test was given.\n    visitor = visitorOrReverse\n    reverse = maybeReverse\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  /**\n   * @param {UnistNode} node\n   * @param {Array<UnistParent>} parents\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1]\n    const index = parent ? parent.children.indexOf(node) : undefined\n    return visitor(node, index, parent)\n  }\n}\n"],"names":["emptyOptions","toString","value","options","settings","one","includeImageAlt","includeHtml","type","alt","all","children","isArray","values","result","index","length","join","own","hasOwnProperty","point","d","line","column","offset","defaultOnError","left","right","unist_util_stringify_position_lib","y","start","end","remarkParse","self","parser","doc","encoding","data","extensions","mdastExtensions","undefined","compiler","config","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","codeFlowValue","definition","identifier","label","title","url","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","listItem","token","spread","_spread","checked","listItemValue","expectingFirstListItemValue","ancestor","stack","Number","parseInt","sliceSerialize","listOrdered","list","listUnordered","paragraph","reference","referenceType","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","node","depth","onexitdata","call","characterEscapeValue","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","characterReferenceType","micromark_util_decode_numeric_character_reference","o","index_dom","T","tail","pop","position","resume","replace","flowCodeInside","codeFencedFence","lang","meta","micromark_util_normalize_identifier","toLowerCase","onexithardbreak","inReference","fragment","labelText","string","micromark_util_decode_string","v","lineEnding","context","atHardBreak","setextHeadingSlurpLineEnding","includes","resource","setextHeadingLineSequence","codePointAt","setextHeadingText","configure","combined","Array","extension","key","push","Object","assign","events","tree","tokenStack","listStack","prepareList","lineIndex","firstBlankLineIndex","atMarker","containerBalance","listSpread","event","tailIndex","tailEvent","splice","item","handler","create","and","errorHandler","siblings","onExitError","open","mdast_util_to_string_lib","B","ordered","postprocess","e","parse","Q","document","write","preprocess","defaultFootnoteBackContent","_","rereferenceIndex","tagName","properties","String","defaultFootnoteBackLabel","referenceIndex","revert","state","subtype","suffix","contents","head","unshift","listItemLoose","handlers_handlers","blockquote","wrap","patch","applyData","break","code","className","delete","footnoteReference","counter","clobberPrefix","id","toUpperCase","safeId","micromark_util_sanitize_uri","F","footnoteOrder","indexOf","reuseCounter","footnoteCounts","get","set","href","dataFootnoteRef","ariaDescribedBy","sup","allowDangerousHtml","imageReference","definitionById","src","inlineCode","text","linkReference","parent","results","loose","listLoose","disabled","child","root","table","rows","firstRow","shift","tableContent","body","unist_util_position_lib","Pk","rb","tableCell","tableRow","rowIndex","align","cellIndex","cells","cell","alignValue","trim_lines","j","toml","ignore","yaml","footnoteDefinition","state_own","from","to","FK","hName","hChildren","hProperties","esm","ZP","nodes","trimMarkdownSpaceStart","charCodeAt","slice","toHast","createState","Map","footnoteById","handlers","handle","passThrough","shallow","unknown","unknownHandler","unist_util_visit_lib","Vn","map","has","foot","footer","footnoteBackContent","footnoteBackLabel","footnoteLabel","footnoteLabelTagName","footnoteLabelProperties","listItems","content","backReferences","counts","dataFootnoteBackref","ariaLabel","tailTail","dataFootnotes","lib_default","ok","remarkRehype","destination","file","hastTree","run","CallableInstance","property","proto","constr","constructor","prototype","apply","arguments","setPrototypeOf","lib_own","Processor","Compiler","Parser","attachers","freezeIndex","frozen","namespace","transformers","trough_lib","r","copy","attacher","use","extend","assertUnfrozen","freeze","transformer","POSITIVE_INFINITY","realFile","vfile","assertParser","process","done","assertCompiler","executor","Promise","resolve","reject","parseTree","realDone","error","compileResult","stringify","processSync","complete","bail","N","assertDone","assertNode","outputTree","resultingTree","runSync","parameters","addPlugin","addList","addPreset","plugins","add","plugin","entryIndex","primary","rest","currentPrimary","is_plain_obj","Z","unified","name","asyncName","looksLikeAVFile","vfile_lib","k","emptyPlugins","emptyRemarkRehypeOptions","safeProtocol","deprecations","Markdown","processor","createProcessor","rehypePlugins","remarkPlugins","remarkRehypeOptions","createFile","t1","post","allowedElements","allowElement","components","disallowedElements","skipHtml","unwrapDisallowed","urlTransform","defaultUrlTransform","deprecation","hasOwn","html_url_attributes_lib","w","test","remove","lib","Fragment","jsx_runtime","ignoreInvalidStyle","jsx","jsxs","passKeys","passNode","colon","questionMark","numberSign","slash","contentDefaults","rehypeAutolinkHeadings","method","headingOroperties","headingProperties","behavior","group","is","hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__","Y","toChildren","toProperties","grouping","toNode","unist_util_visit__WEBPACK_IMPORTED_MODULE_3__","AM","before","after","clone","ariaHidden","tabIndex","unist_util_visit__WEBPACK_IMPORTED_MODULE_1__","hast_util_heading_rank__WEBPACK_IMPORTED_MODULE_2__","thing","_ungap_structured_clone__WEBPACK_IMPORTED_MODULE_4__","emptyClasses","rehypeKatex","unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_1__","S4","element","parents","classes","languageMath","mathDisplay","mathInline","displayMode","scope","hast_util_to_text__WEBPACK_IMPORTED_MODULE_2__","l","whitespace","katex__WEBPACK_IMPORTED_MODULE_0__","renderToString","throwOnError","ruleId","cause","message","ancestors","place","source","strict","style","errorColor","hast_util_from_html_isomorphic__WEBPACK_IMPORTED_MODULE_3__","rehypeRaw","hast_util_raw__WEBPACK_IMPORTED_MODULE_0__","L","slugs","github_slugger__WEBPACK_IMPORTED_MODULE_0__","rehypeSlug","prefix","reset","slug","hast_util_to_string__WEBPACK_IMPORTED_MODULE_3__","inConstruct","notInConstruct","enterLiteralAutolink","enterLiteralAutolinkValue","exitLiteralAutolinkHttp","exitLiteralAutolinkWww","exitLiteralAutolinkEmail","exitLiteralAutolink","transformGfmAutolinkLiterals","findAndReplace","ignored","unist_util_is_lib","O","pairs","toPairs","tupleOrList","find","tuple","escapeStringRegexp","toFunction","pairIndex","visitor","grandparent","change","lastIndex","match","exec","matchObject","input","global","findUrl","findEmail","protocol","domain","path","previous","isCorrectDomain","parts","split","splitUrl","trailExec","trail","closingParenIndex","openingParens","ccount","closingParens","atext","email","micromark_util_character","B8","Xh","enterFootnoteCallString","enterFootnoteCall","enterFootnoteDefinitionLabelString","enterFootnoteDefinition","exitFootnoteCallString","exitFootnoteCall","exitFootnoteDefinitionLabelString","exitFootnoteDefinition","info","tracker","createTracker","move","subexit","safe","associationId","mapExceptFirst","blank","mapAll","peek","constructsWithoutStrikethrough","enterStrikethrough","exitStrikethrough","handleDelete","containerPhrasing","current","sequence","unsafe","pattern","expression","compilePattern","atBreak","listItemIndent","checkListItemIndent","bullet","bulletCurrent","checkBullet","marker","incrementListMarker","size","Math","ceil","repeat","indentLines","containerFlow","enterTable","_align","inTable","exitTable","enterRow","enterCell","exitCodeText","$0","$1","exitCheck","exitParagraphWithTaskListItem","firstParaghraph","sibling","listItemWithTaskListItem","checkable","checkbox","remarkGfm","firstLineBlank","micromarkExtensions","fromMarkdownExtensions","toMarkdownExtensions","micromark_extension_gfm","literalAutolink","literalAutolinkEmail","literalAutolinkHttp","literalAutolinkWww","gfmFootnoteCallString","gfmFootnoteCall","gfmFootnoteDefinitionLabelString","gfmFootnoteDefinition","strikethrough","tableData","tableHeader","taskListCheckValueChecked","taskListCheckValueUnchecked","character","gfmTableToMarkdown","padding","tableCellPadding","alignDelimiters","tablePipeAlign","stringLength","around","serializeData","handleTableAsData","handleTableRowAsData","handleTableCell","matrix","markdown_table","x","remarkMath","syntax","m","mathFromMarkdown","mathFlow","mathFlowFenceMeta","mathText","mathFlowInside","mathFlowFence","mathFlowValue","exitMathData","mathTextData","mathToMarkdown","single","singleDollarTextMath","inlineMath","math","raw","max","longest_streak","J","encode","remarkUnwrapImages","unist_util_visit__WEBPACK_IMPORTED_MODULE_0__","applicable","inLink","hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__","linkResult","findAfter","unist_util_is__WEBPACK_IMPORTED_MODULE_0__","convert","castFactory","anyFactory","tests","checks","nodeAsRecord","checkAsRecord","testFunction","Boolean","looksLikeANode","pointEnd","pointStart","stringifyPosition","pos","empty","EXIT","SKIP","visitParents","reverse","check","step","factory","defineProperty","visit","subresult","grandparents","nodeAsParent","concat","testOrVisitor","visitorOrReverse","maybeReverse","unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_0__"],"sourceRoot":""}