{"version":3,"file":"static/chunks/vendor-f33ddaf2-42ddffa5d4e84044.js","mappings":"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","sources":["webpack://_N_E/./node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/controls/BaseGroup.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/controls/Group.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/utils/is-bezier-definition.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/utils/supports/flags.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/utils/supports/memo.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/waapi/utils/easing.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/utils/resolve-elements.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/utils/setup.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/hover.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/press/index.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/waapi/NativeAnimationControls.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/waapi/utils/convert-options.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/animation/waapi/PseudoAnimation.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/view/utils/css.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/view/start.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/view/index.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs","webpack://_N_E/./node_modules/motion-dom/dist/es/index.mjs","webpack://_N_E/./node_modules/motion-utils/dist/es/errors.mjs","webpack://_N_E/./node_modules/motion-utils/dist/es/memo.mjs","webpack://_N_E/./node_modules/motion-utils/dist/es/noop.mjs","webpack://_N_E/./node_modules/motion-utils/dist/es/progress.mjs","webpack://_N_E/./node_modules/motion-utils/dist/es/time-conversion.mjs"],"sourcesContent":["import { memo } from 'motion-utils';\n\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n","import { supportsScrollTimeline } from '../../utils/supports/scroll-timeline.mjs';\n\nclass BaseGroupPlaybackControls {\n    constructor(animations) {\n        // Bound to accomodate common `return animation.stop` pattern\n        this.stop = () => this.runAll(\"stop\");\n        this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n        // Support for new finished Promise and legacy thennable API\n        return Promise.all(this.animations.map((animation) => \"finished\" in animation ? animation.finished : animation));\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline, fallback) {\n        const subscriptions = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                return animation.attachTimeline(timeline);\n            }\n            else if (typeof fallback === \"function\") {\n                return fallback(animation);\n            }\n        });\n        return () => {\n            subscriptions.forEach((cancel, i) => {\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get startTime() {\n        return this.getAll(\"startTime\");\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    flatten() {\n        this.runAll(\"flatten\");\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nexport { BaseGroupPlaybackControls };\n","import { BaseGroupPlaybackControls } from './BaseGroup.mjs';\n\n/**\n * TODO: This is a temporary class to support the legacy\n * thennable API\n */\nclass GroupPlaybackControls extends BaseGroupPlaybackControls {\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n}\n\nexport { GroupPlaybackControls };\n","function getValueTransition(transition, key) {\n    return transition\n        ? transition[key] ||\n            transition[\"default\"] ||\n            transition\n        : undefined;\n}\n\nexport { getValueTransition };\n","/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nexport { calcGeneratorDuration, maxGeneratorDuration };\n","function isGenerator(type) {\n    return typeof type === \"function\";\n}\n\nexport { isGenerator };\n","function attachTimeline(animation, timeline) {\n    animation.timeline = timeline;\n    animation.onfinish = null;\n}\n\nexport { attachTimeline };\n","const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nexport { isBezierDefinition };\n","/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {\n    linearEasing: undefined,\n};\n\nexport { supportsFlags };\n","import { memo } from 'motion-utils';\nimport { supportsFlags } from './flags.mjs';\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\n}\n\nexport { memoSupports };\n","import { memoSupports } from './memo.mjs';\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement(\"div\")\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, \"linearEasing\");\n\nexport { supportsLinearEasing };\n","import { progress } from 'motion-utils';\n\nconst generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = \"\";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\nexport { generateLinearEasing };\n","import { isBezierDefinition } from '../../../utils/is-bezier-definition.mjs';\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { generateLinearEasing } from './linear.mjs';\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean((typeof easing === \"function\" && supportsLinearEasing()) ||\n        !easing ||\n        (typeof easing === \"string\" &&\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === \"function\" && supportsLinearEasing()) {\n        return generateLinearEasing(easing, duration);\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\nexport { cubicBezierAsString, isWaapiSupportedEasing, mapEasingToNativeEasing, supportedWaapiEasing };\n","const isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\nexport { isDragActive, isDragging };\n","function resolveElements(elementOrSelector, scope, selectorCache) {\n    var _a;\n    if (elementOrSelector instanceof Element) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === \"string\") {\n        let root = document;\n        if (scope) {\n            // TODO: Refactor to utils package\n            // invariant(\n            //     Boolean(scope.current),\n            //     \"Scope provided, but no element detected.\"\n            // )\n            root = scope.current;\n        }\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\nexport { resolveElements };\n","import { resolveElements } from '../../utils/resolve-elements.mjs';\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\nexport { setupGesture };\n","import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\n\n/**\n * Filter out events that are not pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.pointerType === \"touch\" || isDragActive())\n            return;\n        callback(event);\n    };\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = filterEvents((enterEvent) => {\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(enterEvent);\n        if (typeof onHoverEnd !== \"function\" || !target)\n            return;\n        const onPointerLeave = filterEvents((leaveEvent) => {\n            onHoverEnd(leaveEvent);\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\n        });\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    });\n    elements.forEach((element) => {\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\nexport { hover };\n","/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nexport { isNodeOrChild };\n","const isPrimaryPointer = (event) => {\n    if (event.pointerType === \"mouse\") {\n        return typeof event.button !== \"number\" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\nexport { isPrimaryPointer };\n","const focusableElements = new Set([\n    \"BUTTON\",\n    \"INPUT\",\n    \"SELECT\",\n    \"TEXTAREA\",\n    \"A\",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return (focusableElements.has(element.tagName) ||\n        element.tabIndex !== -1);\n}\n\nexport { isElementKeyboardAccessible };\n","const isPressing = new WeakSet();\n\nexport { isPressing };\n","import { isPressing } from './state.mjs';\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== \"Enter\")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, \"down\");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, \"up\");\n        });\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\n    });\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\n\nexport { enableKeyboardPress };\n","import { isDragActive } from '../drag/state/is-active.mjs';\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\nimport { setupGesture } from '../utils/setup.mjs';\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\nimport { isPressing } from './utils/state.mjs';\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(elementOrSelector, onPressStart, options = {}) {\n    const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\n    const startPress = (startEvent) => {\n        const element = startEvent.currentTarget;\n        if (!isValidPressEvent(startEvent) || isPressing.has(element))\n            return;\n        isPressing.add(element);\n        const onPressEnd = onPressStart(startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            window.removeEventListener(\"pointerup\", onPointerUp);\n            window.removeEventListener(\"pointercancel\", onPointerCancel);\n            if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\n                return;\n            }\n            isPressing.delete(element);\n            if (typeof onPressEnd === \"function\") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            onPointerEnd(upEvent, options.useGlobalTarget ||\n                isNodeOrChild(element, upEvent.target));\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n        window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n    };\n    elements.forEach((element) => {\n        if (!isElementKeyboardAccessible(element) &&\n            element.getAttribute(\"tabindex\") === null) {\n            element.tabIndex = 0;\n        }\n        const target = options.useGlobalTarget ? window : element;\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\n        element.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n    });\n    return cancelEvents;\n}\n\nexport { press };\n","import { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { attachTimeline } from './utils/attach-timeline.mjs';\n\nclass NativeAnimationControls {\n    constructor(animation) {\n        this.animation = animation;\n    }\n    get duration() {\n        var _a, _b, _c;\n        const durationInMs = ((_b = (_a = this.animation) === null || _a === void 0 ? void 0 : _a.effect) === null || _b === void 0 ? void 0 : _b.getComputedTiming().duration) ||\n            ((_c = this.options) === null || _c === void 0 ? void 0 : _c.duration) ||\n            300;\n        return millisecondsToSeconds(Number(durationInMs));\n    }\n    get time() {\n        var _a;\n        if (this.animation) {\n            return millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\n        }\n        return 0;\n    }\n    set time(newTime) {\n        if (this.animation) {\n            this.animation.currentTime = secondsToMilliseconds(newTime);\n        }\n    }\n    get speed() {\n        return this.animation ? this.animation.playbackRate : 1;\n    }\n    set speed(newSpeed) {\n        if (this.animation) {\n            this.animation.playbackRate = newSpeed;\n        }\n    }\n    get state() {\n        return this.animation ? this.animation.playState : \"finished\";\n    }\n    get startTime() {\n        return this.animation ? this.animation.startTime : null;\n    }\n    get finished() {\n        return this.animation ? this.animation.finished : Promise.resolve();\n    }\n    play() {\n        this.animation && this.animation.play();\n    }\n    pause() {\n        this.animation && this.animation.pause();\n    }\n    stop() {\n        if (!this.animation ||\n            this.state === \"idle\" ||\n            this.state === \"finished\") {\n            return;\n        }\n        if (this.animation.commitStyles) {\n            this.animation.commitStyles();\n        }\n        this.cancel();\n    }\n    flatten() {\n        var _a;\n        if (!this.animation)\n            return;\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: \"linear\" });\n    }\n    attachTimeline(timeline) {\n        if (this.animation)\n            attachTimeline(this.animation, timeline);\n        return noop;\n    }\n    complete() {\n        this.animation && this.animation.finish();\n    }\n    cancel() {\n        try {\n            this.animation && this.animation.cancel();\n        }\n        catch (e) { }\n    }\n}\n\nexport { NativeAnimationControls };\n","import { millisecondsToSeconds } from 'motion-utils';\nimport { calcGeneratorDuration, maxGeneratorDuration } from './calc-duration.mjs';\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => {\n            return generator.next(duration * progress).value / scale;\n        },\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\nexport { createGeneratorEasing };\n","import { secondsToMilliseconds } from 'motion-utils';\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\nimport { createGeneratorEasing } from '../../generators/utils/create-generator-easing.mjs';\nimport { isGenerator } from '../../generators/utils/is-generator.mjs';\nimport { mapEasingToNativeEasing } from './easing.mjs';\n\nconst defaultEasing = \"easeOut\";\nfunction applyGeneratorOptions(options) {\n    var _a;\n    if (isGenerator(options.type)) {\n        const generatorOptions = createGeneratorEasing(options, 100, options.type);\n        options.ease = supportsLinearEasing()\n            ? generatorOptions.ease\n            : defaultEasing;\n        options.duration = secondsToMilliseconds(generatorOptions.duration);\n        options.type = \"keyframes\";\n    }\n    else {\n        options.duration = secondsToMilliseconds((_a = options.duration) !== null && _a !== void 0 ? _a : 0.3);\n        options.ease = options.ease || defaultEasing;\n    }\n}\n// TODO: Reuse for NativeAnimation\nfunction convertMotionOptionsToNative(valueName, keyframes, options) {\n    var _a;\n    const nativeKeyframes = {};\n    const nativeOptions = {\n        fill: \"both\",\n        easing: \"linear\",\n        composite: \"replace\",\n    };\n    nativeOptions.delay = secondsToMilliseconds((_a = options.delay) !== null && _a !== void 0 ? _a : 0);\n    applyGeneratorOptions(options);\n    nativeOptions.duration = options.duration;\n    const { ease, times } = options;\n    if (times)\n        nativeKeyframes.offset = times;\n    nativeKeyframes[valueName] = keyframes;\n    const easing = mapEasingToNativeEasing(ease, options.duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing)) {\n        nativeKeyframes.easing = easing;\n    }\n    else {\n        nativeOptions.easing = easing;\n    }\n    return {\n        keyframes: nativeKeyframes,\n        options: nativeOptions,\n    };\n}\n\nexport { applyGeneratorOptions, convertMotionOptionsToNative };\n","import { NativeAnimationControls } from './NativeAnimationControls.mjs';\nimport { convertMotionOptionsToNative } from './utils/convert-options.mjs';\n\nclass PseudoAnimation extends NativeAnimationControls {\n    constructor(target, pseudoElement, valueName, keyframes, options) {\n        const animationOptions = convertMotionOptionsToNative(valueName, keyframes, options);\n        const animation = target.animate(animationOptions.keyframes, {\n            pseudoElement,\n            ...animationOptions.options,\n        });\n        super(animation);\n    }\n}\n\nexport { PseudoAnimation };\n","let pendingRules = {};\nlet style = null;\nconst css = {\n    set: (selector, values) => {\n        pendingRules[selector] = values;\n    },\n    commit: () => {\n        if (!style) {\n            style = document.createElement(\"style\");\n            style.id = \"motion-view\";\n        }\n        let cssText = \"\";\n        for (const selector in pendingRules) {\n            const rule = pendingRules[selector];\n            cssText += `${selector} {\\n`;\n            for (const [property, value] of Object.entries(rule)) {\n                cssText += `  ${property}: ${value};\\n`;\n            }\n            cssText += \"}\\n\";\n        }\n        style.textContent = cssText;\n        document.head.appendChild(style);\n        pendingRules = {};\n    },\n    remove: () => {\n        if (style && style.parentElement) {\n            style.parentElement.removeChild(style);\n        }\n    },\n};\n\nexport { css };\n","import { secondsToMilliseconds } from 'motion-utils';\nimport { BaseGroupPlaybackControls } from '../animation/controls/BaseGroup.mjs';\nimport { getValueTransition } from '../animation/utils/get-value-transition.mjs';\nimport { NativeAnimationControls } from '../animation/waapi/NativeAnimationControls.mjs';\nimport { PseudoAnimation } from '../animation/waapi/PseudoAnimation.mjs';\nimport { applyGeneratorOptions } from '../animation/waapi/utils/convert-options.mjs';\nimport { mapEasingToNativeEasing } from '../animation/waapi/utils/easing.mjs';\nimport { chooseLayerType } from './utils/choose-layer-type.mjs';\nimport { css } from './utils/css.mjs';\nimport { getLayerName } from './utils/get-layer-name.mjs';\nimport { getViewAnimations } from './utils/get-view-animations.mjs';\nimport { hasTarget } from './utils/has-target.mjs';\n\nconst definitionNames = [\"layout\", \"enter\", \"exit\", \"new\", \"old\"];\nfunction startViewAnimation(update, defaultOptions, targets) {\n    if (!document.startViewTransition) {\n        return new Promise(async (resolve) => {\n            await update();\n            resolve(new BaseGroupPlaybackControls([]));\n        });\n    }\n    // TODO: Go over existing targets and ensure they all have ids\n    /**\n     * If we don't have any animations defined for the root target,\n     * remove it from being captured.\n     */\n    if (!hasTarget(\"root\", targets)) {\n        css.set(\":root\", {\n            \"view-transition-name\": \"none\",\n        });\n    }\n    /**\n     * Set the timing curve to linear for all view transition layers.\n     * This gets baked into the keyframes, which can't be changed\n     * without breaking the generated animation.\n     *\n     * This allows us to set easing via updateTiming - which can be changed.\n     */\n    css.set(\"::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)\", { \"animation-timing-function\": \"linear !important\" });\n    css.commit(); // Write\n    const transition = document.startViewTransition(async () => {\n        await update();\n        // TODO: Go over new targets and ensure they all have ids\n    });\n    transition.finished.finally(() => {\n        css.remove(); // Write\n    });\n    return new Promise((resolve) => {\n        transition.ready.then(() => {\n            var _a;\n            const generatedViewAnimations = getViewAnimations();\n            const animations = [];\n            /**\n             * Create animations for our definitions\n             */\n            targets.forEach((definition, target) => {\n                // TODO: If target is not \"root\", resolve elements\n                // and iterate over each\n                for (const key of definitionNames) {\n                    if (!definition[key])\n                        continue;\n                    const { keyframes, options } = definition[key];\n                    for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {\n                        if (!valueKeyframes)\n                            continue;\n                        const valueOptions = {\n                            ...getValueTransition(defaultOptions, valueName),\n                            ...getValueTransition(options, valueName),\n                        };\n                        const type = chooseLayerType(key);\n                        /**\n                         * If this is an opacity animation, and keyframes are not an array,\n                         * we need to convert them into an array and set an initial value.\n                         */\n                        if (valueName === \"opacity\" &&\n                            !Array.isArray(valueKeyframes)) {\n                            const initialValue = type === \"new\" ? 0 : 1;\n                            valueKeyframes = [initialValue, valueKeyframes];\n                        }\n                        /**\n                         * Resolve stagger function if provided.\n                         */\n                        if (typeof valueOptions.delay === \"function\") {\n                            valueOptions.delay = valueOptions.delay(0, 1);\n                        }\n                        const animation = new PseudoAnimation(document.documentElement, `::view-transition-${type}(${target})`, valueName, valueKeyframes, valueOptions);\n                        animations.push(animation);\n                    }\n                }\n            });\n            /**\n             * Handle browser generated animations\n             */\n            for (const animation of generatedViewAnimations) {\n                if (animation.playState === \"finished\")\n                    continue;\n                const { effect } = animation;\n                if (!effect || !(effect instanceof KeyframeEffect))\n                    continue;\n                const { pseudoElement } = effect;\n                if (!pseudoElement)\n                    continue;\n                const name = getLayerName(pseudoElement);\n                if (!name)\n                    continue;\n                const targetDefinition = targets.get(name.layer);\n                if (!targetDefinition) {\n                    /**\n                     * If transition name is group then update the timing of the animation\n                     * whereas if it's old or new then we could possibly replace it using\n                     * the above method.\n                     */\n                    const transitionName = name.type === \"group\" ? \"layout\" : \"\";\n                    const animationTransition = {\n                        ...getValueTransition(defaultOptions, transitionName),\n                    };\n                    applyGeneratorOptions(animationTransition);\n                    const easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);\n                    effect.updateTiming({\n                        delay: secondsToMilliseconds((_a = animationTransition.delay) !== null && _a !== void 0 ? _a : 0),\n                        duration: animationTransition.duration,\n                        easing,\n                    });\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else if (hasOpacity(targetDefinition, \"enter\") &&\n                    hasOpacity(targetDefinition, \"exit\") &&\n                    effect\n                        .getKeyframes()\n                        .some((keyframe) => keyframe.mixBlendMode)) {\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else {\n                    animation.cancel();\n                }\n            }\n            resolve(new BaseGroupPlaybackControls(animations));\n        });\n    });\n}\nfunction hasOpacity(target, key) {\n    var _a;\n    return (_a = target === null || target === void 0 ? void 0 : target[key]) === null || _a === void 0 ? void 0 : _a.keyframes.opacity;\n}\n\nexport { startViewAnimation };\n","import { noop } from 'motion-utils';\nimport { startViewAnimation } from './start.mjs';\n\n/**\n * TODO:\n * - Create view transition on next tick\n * - Replace animations with Motion animations\n * - Return GroupAnimation on next tick\n */\nclass ViewTransitionBuilder {\n    constructor(update, options = {}) {\n        this.currentTarget = \"root\";\n        this.targets = new Map();\n        this.notifyReady = noop;\n        this.readyPromise = new Promise((resolve) => {\n            this.notifyReady = resolve;\n        });\n        queueMicrotask(() => {\n            startViewAnimation(update, options, this.targets).then((animation) => this.notifyReady(animation));\n        });\n    }\n    get(selector) {\n        this.currentTarget = selector;\n        return this;\n    }\n    layout(keyframes, options) {\n        this.updateTarget(\"layout\", keyframes, options);\n        return this;\n    }\n    new(keyframes, options) {\n        this.updateTarget(\"new\", keyframes, options);\n        return this;\n    }\n    old(keyframes, options) {\n        this.updateTarget(\"old\", keyframes, options);\n        return this;\n    }\n    enter(keyframes, options) {\n        this.updateTarget(\"enter\", keyframes, options);\n        return this;\n    }\n    exit(keyframes, options) {\n        this.updateTarget(\"exit\", keyframes, options);\n        return this;\n    }\n    crossfade(options) {\n        this.updateTarget(\"enter\", { opacity: 1 }, options);\n        this.updateTarget(\"exit\", { opacity: 0 }, options);\n        return this;\n    }\n    updateTarget(target, keyframes, options = {}) {\n        const { currentTarget, targets } = this;\n        if (!targets.has(currentTarget)) {\n            targets.set(currentTarget, {});\n        }\n        const targetData = targets.get(currentTarget);\n        targetData[target] = { keyframes, options };\n    }\n    then(resolve, reject) {\n        return this.readyPromise.then(resolve, reject);\n    }\n}\nfunction view(update, defaultOptions = {}) {\n    return new ViewTransitionBuilder(update, defaultOptions);\n}\n\nexport { ViewTransitionBuilder, view };\n","import { isDragging } from './is-active.mjs';\n\nfunction setDragLock(axis) {\n    if (axis === \"x\" || axis === \"y\") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\nexport { setDragLock };\n","export { GroupPlaybackControls } from './animation/controls/Group.mjs';\nexport { getValueTransition } from './animation/utils/get-value-transition.mjs';\nexport { calcGeneratorDuration, maxGeneratorDuration } from './animation/generators/utils/calc-duration.mjs';\nexport { createGeneratorEasing } from './animation/generators/utils/create-generator-easing.mjs';\nexport { isGenerator } from './animation/generators/utils/is-generator.mjs';\nexport { NativeAnimationControls } from './animation/waapi/NativeAnimationControls.mjs';\nexport { attachTimeline } from './animation/waapi/utils/attach-timeline.mjs';\nexport { cubicBezierAsString, isWaapiSupportedEasing, mapEasingToNativeEasing, supportedWaapiEasing } from './animation/waapi/utils/easing.mjs';\nexport { generateLinearEasing } from './animation/waapi/utils/linear.mjs';\nexport { hover } from './gestures/hover.mjs';\nexport { press } from './gestures/press/index.mjs';\nexport { isBezierDefinition } from './utils/is-bezier-definition.mjs';\nexport { resolveElements } from './utils/resolve-elements.mjs';\nexport { supportsFlags } from './utils/supports/flags.mjs';\nexport { supportsLinearEasing } from './utils/supports/linear-easing.mjs';\nexport { supportsScrollTimeline } from './utils/supports/scroll-timeline.mjs';\nexport { ViewTransitionBuilder, view } from './view/index.mjs';\nexport { isDragActive, isDragging } from './gestures/drag/state/is-active.mjs';\nexport { setDragLock } from './gestures/drag/state/set-active.mjs';\nexport { isNodeOrChild } from './gestures/utils/is-node-or-child.mjs';\nexport { isPrimaryPointer } from './gestures/utils/is-primary-pointer.mjs';\n","import { noop } from './noop.mjs';\n\nlet warning = noop;\nlet invariant = noop;\nif (process.env.NODE_ENV !== \"production\") {\n    warning = (check, message) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(message);\n        }\n    };\n    invariant = (check, message) => {\n        if (!check) {\n            throw new Error(message);\n        }\n    };\n}\n\nexport { invariant, warning };\n","/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nexport { memo };\n","/*#__NO_SIDE_EFFECTS__*/\nconst noop = (any) => any;\n\nexport { noop };\n","/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n"],"names":["easing_mapEasingToNativeEasing","easing","duration","supportsLinearEasing","generateLinearEasing","isBezierDefinition","cubicBezierAsString","Array","isArray","map","segmentEasing","supportedWaapiEasing","easeOut","supportsScrollTimeline","memo","X","window","undefined","ScrollTimeline","BaseGroup_BaseGroupPlaybackControls","constructor","animations","stop","runAll","filter","Boolean","finished","Promise","all","animation","getAll","propName","setAll","newValue","i","length","attachTimeline","timeline","fallback","subscriptions","forEach","cancel","time","speed","startTime","max","Math","methodName","controls","flatten","play","pause","complete","GroupPlaybackControls","then","onResolve","onReject","catch","get_value_transition_getValueTransition","transition","key","maxGeneratorDuration","calcGeneratorDuration","generator","state","next","done","Infinity","isGenerator","type","onfinish","supportsFlags","linearEasing","memoSupports","callback","supportsFlag","memoized","_a","document","createElement","animate","opacity","e","resolution","points","numPoints","round","progress","Y","substring","isWaapiSupportedEasing","every","a","b","c","d","linear","ease","easeIn","easeInOut","circIn","circOut","backIn","backOut","isDragging","x","y","setupGesture","elementOrSelector","options","elements","resolveElements","scope","selectorCache","Element","root","querySelectorAll","from","gestureAbortController","AbortController","passive","signal","abort","filterEvents","event","pointerType","hover","onHoverStart","eventOptions","onPointerEnter","target","enterEvent","onHoverEnd","onPointerLeave","leaveEvent","removeEventListener","addEventListener","element","isNodeOrChild","parent","child","parentElement","isPrimaryPointer","button","isPrimary","focusableElements","Set","isPressing","WeakSet","keyboard_filterEvents","firePointerEvent","dispatchEvent","PointerEvent","bubbles","enableKeyboardPress","focusEvent","currentTarget","handleKeydown","has","handleKeyup","isValidPressEvent","press","onPressStart","cancelEvents","startPress","startEvent","add","onPressEnd","onPointerEnd","endEvent","success","onPointerUp","onPointerCancel","delete","upEvent","useGlobalTarget","cancelEvent","tagName","tabIndex","getAttribute","setDragLock","axis","warning","_noop_mjs__WEBPACK_IMPORTED_MODULE_0__","Z","invariant","result","noop","any","to","value","toFromDifference","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds"],"sourceRoot":""}