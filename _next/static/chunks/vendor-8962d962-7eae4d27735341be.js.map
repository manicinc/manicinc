{"version":3,"file":"static/chunks/vendor-8962d962-7eae4d27735341be.js","mappings":"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","sources":["webpack://_N_E/./node_modules/micromark-util-character/index.js","webpack://_N_E/./node_modules/micromark-util-chunked/index.js","webpack://_N_E/./node_modules/micromark-util-classify-character/index.js","webpack://_N_E/./node_modules/micromark-util-combine-extensions/index.js","webpack://_N_E/./node_modules/micromark-util-decode-numeric-character-reference/index.js","webpack://_N_E/./node_modules/micromark-util-decode-string/index.js","webpack://_N_E/./node_modules/micromark-util-html-tag-name/index.js","webpack://_N_E/./node_modules/micromark-util-normalize-identifier/index.js","webpack://_N_E/./node_modules/micromark-util-resolve-all/index.js","webpack://_N_E/./node_modules/micromark-util-sanitize-uri/index.js","webpack://_N_E/./node_modules/micromark-util-subtokenize/lib/splice-buffer.js","webpack://_N_E/./node_modules/micromark-util-subtokenize/index.js"],"sourcesContent":["/**\n * @import {Code} from 'micromark-util-types'\n */\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  );\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/);\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2;\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32);\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32;\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(/\\p{P}|\\p{S}/u);\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/);\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n *   Expression.\n * @returns {(code: Code) => boolean}\n *   Check.\n */\nfunction regexCheck(regex) {\n  return check;\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {undefined}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length;\n  let chunkStart = 0;\n  /** @type {Array<unknown>} */\n  let parameters;\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n  remove = remove > 0 ? remove : 0;\n\n  // No need to chunk the items if there‚Äôs only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove);\n    // @ts-expect-error Hush, it‚Äôs fine.\n    list.splice(...parameters);\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove);\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000);\n      parameters.unshift(start, 0);\n      // @ts-expect-error Hush, it‚Äôs fine.\n      list.splice(...parameters);\n      chunkStart += 10000;\n      start += 10000;\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items);\n    return list;\n  }\n  return items;\n}","/**\n * @import {Code} from 'micromark-util-types'\n */\n\nimport { markdownLineEndingOrSpace, unicodePunctuation, unicodeWhitespace } from 'micromark-util-character';\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > üëâ **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n    return 1;\n  }\n  if (unicodePunctuation(code)) {\n    return 2;\n  }\n}","/**\n * @import {\n *   Extension,\n *   Handles,\n *   HtmlExtension,\n *   NormalizedExtension\n * } from 'micromark-util-types'\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine multiple syntax extensions into one.\n *\n * @param {ReadonlyArray<Extension>} extensions\n *   List of syntax extensions.\n * @returns {NormalizedExtension}\n *   A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all\n *   Extension to merge into.\n * @param {Extension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {keyof Extension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    /** @type {Record<string, unknown>} */\n    const left = maybe || (all[hook] = {})\n    /** @type {Record<string, unknown> | undefined} */\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    if (right) {\n      for (code in right) {\n        if (!hasOwnProperty.call(left, code)) left[code] = []\n        const value = right[code]\n        constructs(\n          // @ts-expect-error Looks like a list.\n          left[code],\n          Array.isArray(value) ? value : value ? [value] : []\n        )\n      }\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {Array<unknown>} existing\n *   List of constructs to merge into.\n * @param {Array<unknown>} list\n *   List of constructs to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {Array<unknown>} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine multiple HTML extensions into one.\n *\n * @param {ReadonlyArray<HtmlExtension>} htmlExtensions\n *   List of HTML extensions.\n * @returns {HtmlExtension}\n *   Single combined HTML extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all\n *   Extension to merge into.\n * @param {HtmlExtension} extension\n *   Extension to merge.\n * @returns {undefined}\n *   Nothing.\n */\nfunction htmlExtension(all, extension) {\n  /** @type {keyof HtmlExtension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {keyof Handles} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        // @ts-expect-error assume document vs regular handler are managed correctly.\n        left[type] = right[type]\n      }\n    }\n  }\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCodePoint(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base);\n  if (\n  // C0 except for HT, LF, FF, CR, space.\n  code < 9 || code === 11 || code > 13 && code < 32 ||\n  // Control character (DEL) of C0, and C1 controls.\n  code > 126 && code < 160 ||\n  // Lone high surrogates and low surrogates.\n  code > 55_295 && code < 57_344 ||\n  // Noncharacters.\n  code > 64_975 && code < 65_008 || /* eslint-disable no-bitwise */\n  (code & 65_535) === 65_535 || (code & 65_535) === 65_534 || /* eslint-enable no-bitwise */\n  // Out of range\n  code > 1_114_111) {\n    return \"\\uFFFD\";\n  }\n  return String.fromCodePoint(code);\n}","import { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nconst characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The ‚Äústring‚Äù content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode);\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @param {string} $1\n *   Character escape.\n * @param {string} $2\n *   Character reference.\n * @returns {string}\n *   Decoded value\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1;\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0);\n  if (head === 35) {\n    const head = $2.charCodeAt(1);\n    const hex = head === 120 || head === 88;\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);\n  }\n  return decodeNamedCharacterReference($2) || $0;\n}","/**\n * List of lowercase HTML ‚Äúblock‚Äù tag names.\n *\n * The list, when parsing HTML (flow), results in more relaxed rules (condition\n * 6).\n * Because they are known blocks, the HTML-like syntax doesn‚Äôt have to be\n * strictly parsed.\n * For tag names not in this list, a more strict algorithm (condition 7) is used\n * to detect whether the HTML-like syntax is seen as HTML (flow) or not.\n *\n * This is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * > üëâ **Note**: `search` was added in `CommonMark@0.31`.\n */\nexport const htmlBlockNames = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'search',\n  'section',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n\n/**\n * List of lowercase HTML ‚Äúraw‚Äù tag names.\n *\n * The list, when parsing HTML (flow), results in HTML that can include lines\n * without exiting, until a closing tag also in this list is found (condition\n * 1).\n *\n * This module is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * > üëâ **Note**: `textarea` was added in `CommonMark@0.30`.\n */\nexport const htmlRawNames = ['pre', 'script', 'style', 'textarea']\n","/**\n * Normalize an identifier (as found in references, definitions).\n *\n * Collapses markdown whitespace, trim, and then lower- and uppercase.\n *\n * Some characters are considered ‚Äúuppercase‚Äù, such as U+03F4 (`œ¥`), but if their\n * lowercase counterpart (U+03B8 (`Œ∏`)) is uppercased will result in a different\n * uppercase character (U+0398 (`Œò`)).\n * So, to get a canonical form, we perform both lower- and uppercase.\n *\n * Using uppercase last makes sure keys will never interact with default\n * prototypal values (such as `constructor`): nothing in the prototype of\n * `Object` is uppercase.\n *\n * @param {string} value\n *   Identifier to normalize.\n * @returns {string}\n *   Normalized identifier.\n */\nexport function normalizeIdentifier(value) {\n  return value\n  // Collapse markdown whitespace.\n  .replace(/[\\t\\n\\r ]+/g, \" \")\n  // Trim.\n  .replace(/^ | $/g, '')\n  // Some characters are considered ‚Äúuppercase‚Äù, but if their lowercase\n  // counterpart is uppercased will result in a different uppercase\n  // character.\n  // Hence, to get that form, we perform both lower- and uppercase.\n  // Upper case makes sure keys will not interact with default prototypal\n  // methods: no method is uppercase.\n  .toLowerCase().toUpperCase();\n}","/**\n * @import {Event, Resolver, TokenizeContext} from 'micromark-util-types'\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {ReadonlyArray<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","import { asciiAlphanumeric } from 'micromark-util-character';\nimport { encode } from 'micromark-util-encode';\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | null | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''));\n  if (!protocol) {\n    return value;\n  }\n  const colon = value.indexOf(':');\n  const questionMark = value.indexOf('?');\n  const numberSign = value.indexOf('#');\n  const slash = value.indexOf('/');\n  if (\n  // If there is no protocol, it‚Äôs relative.\n  colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, it‚Äôs not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign ||\n  // It is a protocol, it should be allowed.\n  protocol.test(value.slice(0, colon))) {\n    return value;\n  }\n  return '';\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    /** @type {string} */\n    let replace = '';\n\n    // A correct percent encoded value.\n    if (code === 37 && asciiAlphanumeric(value.charCodeAt(index + 1)) && asciiAlphanumeric(value.charCodeAt(index + 2))) {\n      skip = 2;\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code);\n      }\n    }\n    // Astral.\n    else if (code > 55_295 && code < 57_344) {\n      const next = value.charCodeAt(index + 1);\n\n      // A correct surrogate pair.\n      if (code < 56_320 && next > 56_319 && next < 57_344) {\n        replace = String.fromCharCode(code, next);\n        skip = 1;\n      }\n      // Lone surrogate.\n      else {\n        replace = \"\\uFFFD\";\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code);\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = '';\n    }\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n  return result.join('') + value.slice(start);\n}","/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push(...newElements)` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */\nexport class SpliceBuffer {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  constructor(initial) {\n    /** @type {Array<T>} */\n    this.left = initial ? [...initial] : [];\n    /** @type {Array<T>} */\n    this.right = [];\n  }\n\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError('Cannot access index `' + index + '` in a splice buffer of size `' + (this.left.length + this.right.length) + '`');\n    }\n    if (index < this.left.length) return this.left[index];\n    return this.right[this.right.length - index + this.left.length - 1];\n  }\n\n  /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */\n  get length() {\n    return this.left.length + this.right.length;\n  }\n\n  /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  shift() {\n    this.setCursor(0);\n    return this.right.pop();\n  }\n\n  /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */\n  slice(start, end) {\n    /** @type {number} */\n    const stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop);\n    }\n    if (start > this.left.length) {\n      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n    }\n    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n  }\n\n  /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */\n  splice(start, deleteCount, items) {\n    /** @type {number} */\n    const count = deleteCount || 0;\n    this.setCursor(Math.trunc(start));\n    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n    if (items) chunkedPush(this.left, items);\n    return removed.reverse();\n  }\n\n  /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    return this.left.pop();\n  }\n\n  /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    this.left.push(item);\n  }\n\n  /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    chunkedPush(this.left, items);\n  }\n\n  /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshift(item) {\n    this.setCursor(0);\n    this.right.push(item);\n  }\n\n  /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshiftMany(items) {\n    this.setCursor(0);\n    chunkedPush(this.right, items.reverse());\n  }\n\n  /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */\n  setCursor(n) {\n    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n    if (n < this.left.length) {\n      // Move cursor to the this.left\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.right, removed.reverse());\n    } else {\n      // Move cursor to the this.right\n      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.left, removed.reverse());\n    }\n  }\n}\n\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  let chunkStart = 0;\n  if (right.length < 10000) {\n    list.push(...right);\n  } else {\n    while (chunkStart < right.length) {\n      list.push(...right.slice(chunkStart, chunkStart + 10000));\n      chunkStart += 10000;\n    }\n  }\n}","/**\n * @import {Chunk, Event, Token} from 'micromark-util-types'\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { SpliceBuffer } from './lib/splice-buffer.js';\n\n// Hidden API exposed for testing.\nexport { SpliceBuffer } from './lib/splice-buffer.js';\n\n/**\n * Tokenize subcontent.\n *\n * @param {Array<Event>} eventsArray\n *   List of events.\n * @returns {boolean}\n *   Whether subtokens were found.\n */\n// eslint-disable-next-line complexity\nexport function subtokenize(eventsArray) {\n  /** @type {Record<string, number>} */\n  const jumps = {};\n  let index = -1;\n  /** @type {Event} */\n  let event;\n  /** @type {number | undefined} */\n  let lineIndex;\n  /** @type {number} */\n  let otherIndex;\n  /** @type {Event} */\n  let otherEvent;\n  /** @type {Array<Event>} */\n  let parameters;\n  /** @type {Array<Event>} */\n  let subevents;\n  /** @type {boolean | undefined} */\n  let more;\n  const events = new SpliceBuffer(eventsArray);\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n    event = events.get(index);\n\n    // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n    if (index && event[1].type === \"chunkFlow\" && events.get(index - 1)[1].type === \"listItemPrefix\") {\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"lineEndingBlank\") {\n        otherIndex += 2;\n      }\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"content\") {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === \"content\") {\n            break;\n          }\n          if (subevents[otherIndex][1].type === \"chunkText\") {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    }\n\n    // Enter.\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    }\n    // Exit.\n    else if (event[1]._container) {\n      otherIndex = index;\n      lineIndex = undefined;\n      while (otherIndex--) {\n        otherEvent = events.get(otherIndex);\n        if (otherEvent[1].type === \"lineEnding\" || otherEvent[1].type === \"lineEndingBlank\") {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events.get(lineIndex)[1].type = \"lineEndingBlank\";\n            }\n            otherEvent[1].type = \"lineEnding\";\n            lineIndex = otherIndex;\n          }\n        } else if (otherEvent[1].type === \"linePrefix\" || otherEvent[1].type === \"listItemIndent\") {\n          // Move past.\n        } else {\n          break;\n        }\n      }\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = {\n          ...events.get(lineIndex)[1].start\n        };\n\n        // Switch container exit w/ line endings.\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        events.splice(lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n\n  // The changes to the `events` buffer must be copied back into the eventsArray\n  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));\n  return !more;\n}\n\n/**\n * Tokenize embedded tokens.\n *\n * @param {SpliceBuffer<Event>} events\n *   Events.\n * @param {number} eventIndex\n *   Index.\n * @returns {Record<string, number>}\n *   Gaps.\n */\nfunction subcontent(events, eventIndex) {\n  const token = events.get(eventIndex)[1];\n  const context = events.get(eventIndex)[2];\n  let startPosition = eventIndex - 1;\n  /** @type {Array<number>} */\n  const startPositions = [];\n  let tokenizer = token._tokenizer;\n  if (!tokenizer) {\n    tokenizer = context.parser[token.contentType](token.start);\n    if (token._contentTypeTextTrailing) {\n      tokenizer._contentTypeTextTrailing = true;\n    }\n  }\n  const childEvents = tokenizer.events;\n  /** @type {Array<[number, number]>} */\n  const jumps = [];\n  /** @type {Record<string, number>} */\n  const gaps = {};\n  /** @type {Array<Chunk>} */\n  let stream;\n  /** @type {Token | undefined} */\n  let previous;\n  let index = -1;\n  /** @type {Token | undefined} */\n  let current = token;\n  let adjust = 0;\n  let start = 0;\n  const breaks = [start];\n\n  // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n  while (current) {\n    // Find the position of the event for this token.\n    while (events.get(++startPosition)[1] !== current) {\n      // Empty.\n    }\n    startPositions.push(startPosition);\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current);\n      if (!current.next) {\n        stream.push(null);\n      }\n      if (previous) {\n        tokenizer.defineSkip(current.start);\n      }\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n      tokenizer.write(stream);\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n      }\n    }\n\n    // Unravel the next token.\n    previous = current;\n    current = current.next;\n  }\n\n  // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n  current = token;\n  while (++index < childEvents.length) {\n    if (\n    // Find a void token that includes a break.\n    childEvents[index][0] === 'exit' && childEvents[index - 1][0] === 'enter' && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n      start = index + 1;\n      breaks.push(start);\n      // Help GC.\n      current._tokenizer = undefined;\n      current.previous = undefined;\n      current = current.next;\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = [];\n\n  // If there‚Äôs one more token (which is the cases for lines that end in an\n  // EOF), that‚Äôs perfect: the last point we found starts it.\n  // If there isn‚Äôt then make sure any remaining content is added to it.\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined;\n    current.previous = undefined;\n  } else {\n    breaks.pop();\n  }\n\n  // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices aren‚Äôt affected.\n  index = breaks.length;\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1]);\n    const start = startPositions.pop();\n    jumps.push([start, start + slice.length - 1]);\n    events.splice(start, 2, slice);\n  }\n  jumps.reverse();\n  index = -1;\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n  return gaps;\n}"],"names":["asciiAlpha","regexCheck","asciiAlphanumeric","asciiAtext","asciiControl","code","asciiDigit","asciiHexDigit","asciiPunctuation","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","unicodePunctuation","unicodeWhitespace","regex","test","String","fromCharCode","splice","list","start","remove","items","parameters","end","length","chunkStart","Array","from","unshift","slice","push","classifyCharacter","micromark_util_character__WEBPACK_IMPORTED_MODULE_0__","z3","B8","Xh","hasOwnProperty","combineExtensions","extensions","all","index","syntaxExtension","extension","hook","left","maybe","call","undefined","right","value","constructs","existing","before","add","micromark_util_chunked__WEBPACK_IMPORTED_MODULE_0__","d","isArray","decodeNumericCharacterReference","base","Number","parseInt","fromCodePoint","characterEscapeOrReference","decodeString","replace","decode","$0","$1","$2","head","charCodeAt","hex","micromark_util_decode_numeric_character_reference__WEBPACK_IMPORTED_MODULE_0__","o","decode_named_character_reference__WEBPACK_IMPORTED_MODULE_1__","T","htmlBlockNames","htmlRawNames","normalizeIdentifier","toLowerCase","toUpperCase","resolveAll","events","context","called","resolve","includes","normalizeUri","result","skip","H$","next","encodeURIComponent","join","SpliceBuffer","constructor","initial","get","shift","setCursor","pop","stop","POSITIVE_INFINITY","reverse","concat","deleteCount","Math","trunc","removed","chunkedPush","item","pushMany","unshiftMany","n","subtokenize","eventsArray","event","lineIndex","otherIndex","otherEvent","subevents","more","jumps","type","_tokenizer","_isInFirstContentOfListItem","contentType","Object","assign","subcontent","eventIndex","stream","previous","token","startPosition","startPositions","tokenizer","parser","_contentTypeTextTrailing","childEvents","gaps","current","adjust","breaks","sliceStream","defineSkip","_gfmTasklistFirstContentOfListItem","write","line","_container","micromark_util_chunked"],"sourceRoot":""}