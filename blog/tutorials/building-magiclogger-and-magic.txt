3:I[4707,[],""]
6:I[36423,[],""]
a:I[6322,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
b:I[96313,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
c:I[66159,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
d:I[59970,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
e:I[81775,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
f:I[12025,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"ThemeProvider"]
10:I[39976,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"CookieProvider"]
11:I[69088,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
12:I[50513,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
13:I[83551,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
14:I[38483,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
15:I[81695,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
16:I[28602,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
17:I[51052,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"Nav"]
18:I[10376,["7601","static/chunks/app/error-49b903ad1792e7dd.js"],"default"]
19:I[79229,["9160","static/chunks/app/not-found-4a8f4262cf75a0c3.js"],"default"]
1a:I[85745,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
1b:I[16049,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
1c:I[18133,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
1d:I[36623,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
1e:I[31214,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","2200","static/chunks/react-icons-4a585cd61d1bc97f.js","8592","static/chunks/common-615310b0e34020f5.js","3185","static/chunks/app/layout-8cb91a341f1a8975.js"],"default"]
4:["category","tutorials","d"]
5:["slug","building-magiclogger-and-magic","d"]
7:T4bb,
          /* Critical CSS - Inline in <head> for fast initial paint */
          :root{--bg-primary:#fbf6ef;--bg-primary-rgb:251,246,239;--text-primary:#4a3f35;--text-primary-rgb:74,63,53;--accent-primary:#d6a574;--accent-highlight:#7de8c9;--header-height:72px}html{background-color:#fbf6ef;color:#4a3f35}html.dark{background-color:#22182b!important;color:#f5f0e6!important}html:not([data-theme-loaded="true"]) body{opacity:0}body{margin:0;font-family:Inter,system-ui,sans-serif;line-height:1.6}main{min-height:100vh}nav{position:sticky;top:0;z-index:100;background:rgba(251,246,239,.95);backdrop-filter:blur(10px);min-height:var(--header-height,72px)}.dark nav{background:rgba(34,24,43,.95)}.hero-section{padding:4rem 1rem;max-width:1200px;margin:0 auto}h1{font-size:clamp(2rem,5vw,4rem);font-weight:700;line-height:1.1;margin:0 0 1rem}img{max-width:100%;height:auto;display:block}.skeleton{background:linear-gradient(90deg,#f0f0f0 25%,#e0e0e0 50%,#f0f0f0 75%);background-size:200% 100%;animation:loading 1.5s ease-in-out infinite}@keyframes loading{0%{background-position:200% 0}100%{background-position:-200% 0}}.dark .skeleton{background:linear-gradient(90deg,#2a2a2a 25%,#3a3a3a 50%,#2a2a2a 75%)}
        8:T6fb,default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.googletagmanager.com https://www.google.com https://www.gstatic.com https://www.clarity.ms https://*.clarity.ms https://cdn.sender.net https://app.sender.net https://api.sender.net *.sender.net https://vercel.live https://*.vercel.app https://cdnjs.cloudflare.com https://ajax.cloudflare.com https://va.vercel-scripts.com https://*.vercel-scripts.com https://eocampaign1.com https://*.eocampaign1.com https://emailoctopus.com https://*.emailoctopus.com https://static.cloudflareinsights.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://www.gstatic.com https://cdn.sender.net https://cdnjs.cloudflare.com https://eocampaign1.com https://*.eocampaign1.com; img-src 'self' data: https: blob: https://www.google.com https://www.gstatic.com https://cdn.sender.net https://app.sender.net https://eocampaign1.com https://*.eocampaign1.com; font-src 'self' https://fonts.gstatic.com https://www.gstatic.com https://cdn.sender.net https://cdnjs.cloudflare.com https://eocampaign1.com; connect-src 'self' https://www.google-analytics.com https://www.google.com https://www.gstatic.com https://api.github.com https://*.github.com https://cdn.sender.net https://app.sender.net https://api.sender.net *.sender.net https://vercel.live https://cloudflare.com https://*.cloudflare.com https://va.vercel-scripts.com https://*.vercel-scripts.com https://eocampaign1.com https://*.eocampaign1.com https://emailoctopus.com https://*.emailoctopus.com https://static.cloudflareinsights.com; frame-src 'self' https://www.google.com https://www.gstatic.com https://cdn.sender.net https://app.sender.net https://eocampaign1.com https://*.eocampaign1.com https://emailoctopus.com https://*.emailoctopus.com;9:Taf1,
        (function() {
          try {
            // Don't run this script during server-side rendering
            if (typeof window === 'undefined' || typeof document === 'undefined') return;
            
            // 1. Check localStorage - the source of truth for user preference
            let storedTheme = localStorage.getItem('theme');
            
            // 2. If no stored theme, check system preference
            if (!storedTheme) {
              const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
              storedTheme = systemPrefersDark ? 'dark' : 'light';
              // Save this to localStorage for next time
              localStorage.setItem('theme', storedTheme);
            }
            
            // Wait for DOM to be ready
            const applyTheme = () => {
              // Safety check that DOM is ready
              if (!document || !document.documentElement) return;
              
              // 3. Ensure clean state
              document.documentElement.classList.remove('dark', 'light');
              
              // 4. Apply theme class and colorScheme
              document.documentElement.classList.add(storedTheme);
              document.documentElement.style.colorScheme = storedTheme;
              
              // 5. Apply immediate colors to prevent flash - only to html element
              if (storedTheme === 'dark') {
                document.documentElement.style.setProperty('background-color', '#22182b', 'important');
                document.documentElement.style.setProperty('color', '#f5f0e6', 'important');
              } else {
                document.documentElement.style.setProperty('background-color', '#fbf6ef', 'important');
                document.documentElement.style.setProperty('color', '#4a3f35', 'important');
              }
              
              // 6. Store for React
              window.__NEXT_THEME_INITIAL = storedTheme;
            };
            
            // Apply theme immediately
            applyTheme();
            
            // Also apply after DOM is fully loaded (for safety)
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', applyTheme);
            }
            
          } catch (e) {
            console.error('Theme initialization error:', e);
            // Fallback to light - only set on html element
            if (document && document.documentElement) {
              document.documentElement.classList.add('light');
              document.documentElement.style.setProperty('background-color', '#fbf6ef', 'important');
              document.documentElement.style.setProperty('color', '#4a3f35', 'important');
            }
          }
        })();
      0:["manic-agency-1762872530971",[[["",{"children":["blog",{"children":[["category","tutorials","d"],{"children":[["slug","building-magiclogger-and-magic","d"],{"children":["__PAGE__?{\"category\":\"tutorials\",\"slug\":\"building-magiclogger-and-magic\"}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["category","tutorials","d"],{"children":[["slug","building-magiclogger-and-magic","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/208a785ace114097.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/7f66dc5b0a63ac85.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/6aa1640f493ba0ea.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","3",{"rel":"stylesheet","href":"/_next/static/css/4cbefeb79a2a2aa3.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","4",{"rel":"stylesheet","href":"/_next/static/css/69d5543744219707.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","5",{"rel":"stylesheet","href":"/_next/static/css/a797a13571b390ed.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","6",{"rel":"stylesheet","href":"/_next/static/css/a0b0de0981628675.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","7",{"rel":"stylesheet","href":"/_next/static/css/84fd462a876106bb.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","className":"\n            __variable_f367f3\n            __variable_47a102\n            __variable_1c86d0\n            __variable_fcc734\n        ","suppressHydrationWarning":true,"children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com","crossOrigin":""}],["$","link",null,{"rel":"preconnect","href":"https://www.googletagmanager.com"}],["$","link",null,{"rel":"preconnect","href":"https://eocampaign1.com"}],["$","link",null,{"rel":"preconnect","href":"https://images.weserv.nl"}],["$","link",null,{"rel":"dns-prefetch","href":"https://cdn.sender.net"}],["$","link",null,{"rel":"dns-prefetch","href":"https://api.github.com"}],["$","link",null,{"rel":"dns-prefetch","href":"https://www.clarity.ms"}],["$","link",null,{"rel":"dns-prefetch","href":"https://eocampaign1.com"}],["$","style",null,{"dangerouslySetInnerHTML":{"__html":"$7"}}],["$","meta",null,{"httpEquiv":"Content-Security-Policy","content":"$8"}],[["$","meta",null,{"name":"cf-visitor","content":"{\"scheme\":\"https\"}"}],["$","meta",null,{"httpEquiv":"X-Forwarded-Proto","content":"https"}]],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"$9"}}]]}],["$","body",null,{"children":[["$","$La",null,{}],["$","$Lb",null,{}],["$","$Lc",null,{}],["$","$Ld",null,{"fallback":["$","$Le",null,{}],"children":["$","$Lf",null,{"children":["$","$L10",null,{"children":[["$","$L11",null,{}],["$","$L12",null,{}],["$","$L13",null,{}],["$","$L14",null,{}],["$","$L15",null,{}],["$","$L16",null,{}],["$","$L17",null,{}],["$","main",null,{"role":"main","id":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$18","errorStyles":[],"errorScripts":[],"template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$L19",null,{}],"notFoundStyles":[]}]}],["$","$L1a",null,{}],["$","$L1b",null,{}],["$","$L1c",null,{}],["$","$L1d",null,{}],["$","$L1e",null,{}]]}]}]}]]}]]}]],null],null],["$L1f",null]]]]
20:I[54680,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
21:I[18745,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
22:I[94058,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
24:I[67373,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
26:I[12554,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
27:I[96670,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
28:I[71409,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
29:I[87634,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
3d:I[72972,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],""]
3e:I[50301,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"IconArrowLeft"]
3f:I[50301,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"IconOrnateAuthor"]
40:I[50301,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"IconOrnateCalendar"]
41:I[50301,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"IconOrnateClock"]
42:I[50301,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"IconOrnateTag"]
43:I[65878,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"Image"]
44:I[30603,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"CustomMarkdownRenderer"]
46:I[74644,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
47:I[75541,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
4a:I[28054,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
4b:I[4681,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
4c:I[99775,["9464","static/chunks/framer-motion-b47ceb0cc30f401f.js","5987","static/chunks/lucide-react-863bdfc8885f406b.js","8592","static/chunks/common-615310b0e34020f5.js","2819","static/chunks/app/blog/%5Bcategory%5D/%5Bslug%5D/page-8a3a630004b6247b.js"],"default"]
23:T642c,# Building MagicLogger and MAGIC: A Universal Logging Standard for Color

**GitHub link: [https://github.com/manicinc/magiclogger](https://github.com/manicinc/magiclogger)**

![MagicLogger Terminal demo|size=large|align=center|effect=glow|border=gradient|caption=MagicLogger Terminal demo](/assets/projects/magiclogger/magiclogger-terminal-demo.gif)

MagicLogger is a library based on an experimental philosophy: **what if better-designed logs meant we needed fewer of them?**

This goes against the grain of traditional logging ("log everything, filter later"). Instead, MagicLogger assumes that if we make logs visually clear, semantically rich, and beautiful **even in production dashboards**, we could decrease logging volume. The more context and clarity in each log, the fewer logs we need overall. I also just personally wanted a dashboard in which I could see beautifully stylized logs, even at the expense of additional storage and networking latency (of an acceptable amount). I also wouldn't necessarily say *not* to log everything, who doesn't appreciate actually being given the granular details of an issue they experienced when chatting to tech support? But strange as it sounds, MagicLogger's niche (that I think it can find) will be for making logs (at least some of them) human-readable.

Using this library generally means you're okay with these assumptions:

  - Storage is cheap, some extra kb in many web apps makes little difference (if you don't care about an image being 1.1 vs 1.0 mb this likely applies)
  - Some logs sent in production will require human review consistently
  - When you analyze logs at a high-level you want to have a visually appealing experience

MagicLogger achieves **165K ops/sec plain text, 120K+ ops/sec with styled output** (faster than bunyan, slower than pino and Winston) while providing full MAGIC schema compliance and OpenTelemetry integration out of the box. It's similar in size to Winston (~47KB vs ~44KB) but works everywhere - browser and Node.js with the same API, and is fully written in TypeScript.

> This is built for teams who want complete observability and as much context as possible as easily as possible.

## Startups Should Consider Open-Source

A skilled senior or staff dev can fully ideate, develop, release, distribute, and even possibly market all on their own, which generally comes more in handy for startups than larger orgs.

Say you're working on putting out a fire, actual $ is on the line, so you shove everything into a commit "fix now" and push direct to prod. Private IP can afford this luxury; open source not so much.

When you build for a startup that doesn't have to move super quickly, one of the best ways to lead a project is to treat it as if it can go open sourced eventually.

From [2023 State of Open Source Report](https://www.linuxfoundation.org/research/world-of-open-source-2023-deep-dive-north-america), 90% of IT leaders are using enterprise open source solutions. Plan accordingly.

**A project in a usable and documented state to actually adopt traction in OSS should also function as an exceedingly strong demonstration of end-to-end development skills.**

## Can we get some color in our logs?

I have been remaking high-level loggers for years like in [Restless](https://github.com/jddunn/restless/blob/master/restless/components/utils/logger.py).

Industry standard libraries for JS, like [winston](https://github.com/winstonjs/winston) are powerful but don't have the most straightforward APIs. [Pino](https://github.com/pinojs/pino) is great, lightweight and fast, but simple by design and **Node.js only**. Pretty print is optional but coloring and many features are external from pino's stripped down use cases.

**Here's how different libraries handle colors in the JS ecosystem:**

Winston requires multiple packages and complex configuration:

```javascript
import winston from 'winston';

// Basic setup - colors need explicit configuration
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.colorize(), // This only works for console
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message }) => {
      return `${timestamp} [${level}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'app.log' }) // No colors here!
  ]
});

// Want to style part of a message? You need chalk
import chalk from 'chalk';
logger.info(`User ${chalk.cyan('john@example.com')} logged in`);
// File output: "User john@example.com logged in" (no color info preserved)
```

Pino deliberately excludes colors from production:

```javascript
import pino from 'pino';

// Basic pino - NO COLORS AT ALL
const logger = pino();
logger.info('Server started'); // {"level":30,"time":1234567890,"msg":"Server started"}

// Want colors? Need pino-pretty (200KB extra!)
const logger = pino({
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true
    }
  }
});

// Even with pino-pretty, you can't style parts of messages
// Want colors in production? Against pino's philosophy
// Want to use in browser? Not supported
```

Now MagicLogger's styling:

```javascript
// MAGICLOGGER (preserves everything, works everywhere)
import { Logger } from 'magiclogger';
const logger = new Logger();

logger.error('<red.bold>CRITICAL:</> Database <yellow>MongoDB</> unreachable');
// Console: Beautifully styled
// File: {"message": "CRITICAL: Database MongoDB unreachable", 
//        "styles": [[0, 9, "red.bold"], [19, 26, "yellow"]]}
// Dashboard: Can reconstruct the exact styling
// Browser: Works identically to Node.js
```

> MagicLogger isn't just adding colors - it's preserving the **semantic meaning** of those colors throughout your entire logging pipeline.

## Designing the Task

> **MagicLogger is a TypeScript logging library with colors, styles, and complete observability built-in. It works in browsers and Node.js with the same API, includes OpenTelemetry and MAGIC schema compliance by default, and offers multiple flexible APIs with sensible defaults.**

Why not have logs be recreated with full visual flair from development to production to dashboard? Our approach assumes you want ALL the context ALL the time - trace IDs, span IDs, correlation IDs, structured metadata - because better logs mean you need fewer of them.

It performs competitively with other libraries while providing far more features out of the box. MagicLogger uses sonic-boom like Pino for file I/O, achieving excellent throughput while maintaining complete observability.

> For example, `chalk.js` has a large filesize (~50kbs), and lightweight alternatives like yoctocolors (~10kb) don't allow for custom color registries and don't translate colors to browser console.

Some of MagicLogger's novel implementations: 

- **Universal Compatibility** - Same API in browsers and Node.js (unique among production loggers)
- **Style Parser/Extractor** (`Stylizer`) - The MAGIC schema's style preservation is novel
- **Custom Color Registry** (`ColorRegistry`) - No other library offers RGB/hex registration with fallbacks
- **Terminal Capability Matrix** (`Terminal`) - Supports built-in fallback chains for styles
- **Full Observability by Default** - OpenTelemetry context, trace IDs, span IDs in every log

## Start Simple, Build Structure

I started simple. Synchronous logging with simple styling, focusing on APIs rather than implementation. Slow at first, easy to optimize later.

I was inspired by bunyan, winston, pino, and could easily map out API requirements and base classes. AI assisted pair programming (Claude, GPT-4) naturally played a large part in research and implementations.

```
src/
├── async/           # AsyncLogger with immediate dispatch
├── colors/          # Custom color registry
├── core/            # Core components
│   ├── BrowserLogger # Browser logger inherited from base
│   ├── Colorizer    # Stylizer for logger text with ANSI color codes
│   ├── Formatter    # Formats text appropriately based on Terminal detection
│   ├── FileManager  # File I/O management
│   ├── LoggerBase   # Core Logger functionality
│   ├── NodeLogger   # Node Logger inherited from base
│   └── Printer      # Console interactions
├── extensions/      # Optional features (redaction, sampling)
├── middleware/      # Middleware system
├── parsers/         # Template and style parsers
├── sync/            # Synchronous implementation
├── theme/           # Theming system
├── transports/      # Transport implementations
├── types/           # TypeScript type definitions
├── utils/           # Utilities
└── validation/      # Schema validation (lazy-loaded)
```

Here's our tsup config to handle complex build requirements:

```typescript
// tsup.config.ts
export default defineConfig((options) => ({
  entry: {
    index: 'src/index.ts',
    'transports/console': 'src/transports/console.ts',
    'transports/file': 'src/transports/file.ts',
    // ... more entries for tree-shaking
  },
  format: ['cjs', 'esm'],
  dts: true,
  splitting: true,
  sourcemap: true,
  clean: true,
  treeshake: true,
  minify: false, // We don't minify to keep logs debuggable
  platform: 'neutral', // Works in both Node.js and browsers
  target: 'es2022'
}));
```

Tree-shaking allows modern bundlers to eliminate dead code, so if you only import the core logger without transports, you don't pay the bundle size cost.

## MAGIC Schema - Complete Observability by Default

**Introducing the MAGIC schema...**

The [MAGIC schema](https://github.com/manicinc/magiclogger/blob/master/docs/magic_schema.md) (MagicLog Agnostic Generic Interface for Consistency), an open format for structured log entries that enables seamless integration and recreation of logging styles. **Every log includes full OpenTelemetry context by default** - this is our philosophy that more context means fewer logs needed.

```typescript
// Example MAGIC schema entry - ALL fields included by default
{
  "timestamp": "2024-01-15T10:30:45.123Z",
  "level": "info",
  "message": "Server started on port 3000",
  "styles": [
    [0, 14, "green.bold"],
    [23, 27, "yellow"]
  ],
  "context": {
    "service": "api-gateway",
    "version": "2.1.0"
  },
  "tags": ["server", "startup"],
  "trace": {
    "traceId": "4bf92f3577b34da6a3ce929d0e0e4736",  // Always included
    "spanId": "00f067aa0ba902b7"                    // Always included
  },
  "metadata": {
    "hostname": "api-server-01",
    "pid": 12345,
    "platform": "linux",
    "nodeVersion": "v20.10.0"
  }
}
```

This complete observability approach means you can correlate any log with distributed traces, understand the full context, and need fewer logs to debug issues.

## Making Things Fast

### Immediate Dispatch Architecture

MagicLogger uses an **immediate dispatch architecture** for writing to file / console, and intelligent, configurable batching options for each transport.

```typescript
// src/async/AsyncLogger.ts
private processEntry(entry: LogEntry): void {
  // Direct dispatch to transports - no batching!
  if (!this.hasNetworkTransports) {
    // Immediate dispatch for file/console
    this.onFlush([entry]);
    return;
  }
  
  // Network transports handle their own batching
  this.addToBatch(entry);
}
```

### Optional Ring Buffer for High-Throughput

While MagicLogger uses immediate dispatch by default, it includes an optional ring buffer implementation for extreme throughput scenarios:

```typescript
// src/async/AsyncLogger.ts - Optional configuration
const logger = new AsyncLogger({
  useRingBuffer: true,  // Enable for 150K+ ops/sec
  worker: {
    enabled: true,      // Required for ring buffer
    poolSize: 1         // Single worker for lock-free operation
  }
});
```

The ring buffer provides:
- Fixed memory allocation (no GC pressure)
- Lock-free operation with atomic instructions
- O(1) write complexity
- Drop policy for overload protection

Most applications won't need this - the default immediate dispatch with sonic-boom achieves excellent performance for typical workloads.

### Style Extraction and Colorization

Style extraction from our angle-bracket and other templating syntax efficiently is done in one-pass in linear time and memory.

**Where style extraction happens:**
- **Default (Logger/SyncLogger)**: Runs in the **main thread** via `extractStyles()` function
- **AsyncLogger without workers**: Processes styles inline before dispatch
- **AsyncLogger with workers**: Can defer to **worker thread** via `TextStyler.parseBracketsWithExtraction()` *if* set

```typescript
// src/utils/style-extractor.ts
export function extractStyles(message: string): ExtractedStyles {
  // Array accumulation is more efficient than string concatenation
  // JavaScript strings are immutable, causing O(n²) complexity with +=
  // Using array + join() gives us O(n) complexity
  const plainParts: string[] = [];
  const styleRanges: StyleRange[] = [];
  
  // We track two indices as we loop through once
  let currentPos = 0;      // Position in original (with tags)
  let plainTextPos = 0;    // Position in output (without tags)
  
  // Regex breakdown for performance:
  // <([^>]+)>  - Opening tag: [^>]+ prevents backtracking
  // ([^<]*)    - Content: deterministic matching
  // <\/>       - Closing tag: literal match
  // The 'g' flag enables single-pass global matching
  const regex = /<([^>]+)>([^<]*)<\/>/g;
  let lastIndex = 0;
  let match;
  
  // Main extraction loop - O(n) complexity
  while ((match = regex.exec(message)) !== null) {
    // Phase 1: Capture unstyled text before match
    if (match.index > lastIndex) {
      const plainText = message.slice(lastIndex, match.index);
      plainParts.push(plainText);
      plainTextPos += plainText.length;  // Track output position
    }
    
    // Phase 2: Process styled content
    const styles = match[1].split('.');  // "red.bold" → ["red", "bold"]
    const content = match[2];
    
    if (content) {
      // Store style range for MAGIC schema
      // Positions are relative to PLAIN TEXT output
      styleRanges.push({
        start: plainTextPos,
        end: plainTextPos + content.length,
        styles
      });
      plainParts.push(content);
      plainTextPos += content.length;
    }
    
    lastIndex = regex.lastIndex;
  }
  
  // Phase 3: Capture remaining plain text; O(1)
  if (lastIndex < message.length) {
    plainParts.push(message.slice(lastIndex));
  }
  
  return {
    plainText: plainParts.join(''),  // O(N)
    styles: styleRanges
  };
}
```

**Fast Path for Plain Text**:
```typescript
// Skip regex entirely if no angle brackets detected
if (!message.includes('<')) {
  return { plainText: message, styles: [] };
}
```

**LRU Cache for Repeated Patterns**:
```typescript
const styleCache = new LRUCache<string, ExtractedStyles>(10000);
const cached = styleCache.get(message);
if (cached) return cached;
```

#### Edge Cases and Design Decisions

**Nested Styles** (Not Supported):
- Input: `<red>outer <blue>inner</> text</>` (supported syntax is <red.blue>)
- Would require stack-based parser, adding complexity
- Design decision: Keep styles flat for simplicity and performance

**Malformed Input** (Graceful Degradation):
- Unclosed tags: `<red>text without closing` → Becomes plain text
- Empty tags: `<red></>` → Skipped via `if (content)` check
- Special characters: `<red>Code: {}</>` → Handled correctly with `[^<]*`

### Performance Comparison

| Logger | Architecture | Plain Text | Styled | Bundle | Works In |
|--------|--------------|------------|---------|---------|----------|
| Pino | Async I/O, Node-only | 560K ops/sec | N/A | 25KB | Node.js only |
| Winston (Plain) | Multi-stream, Node-only | 307K ops/sec | N/A | 44KB | Node.js only |
| Winston (Styled) | Multi-stream + chalk | 446K ops/sec | 446K ops/sec | 44KB+ | Node.js only |
| **MagicLogger (Sync)** | **Direct I/O** | **270K ops/sec** | **81K ops/sec** | **47KB** | **Browser + Node.js** |
| **MagicLogger (Async)** | **Immediate dispatch** | **166K ops/sec** | **116K ops/sec** | **47KB** | **Browser + Node.js** |
| Bunyan | JSON, Node-only | 85K ops/sec | 99K ops/sec | 30KB | Node.js only |

**Key insights**:
- MagicLogger is the only production logger that works in both browsers and Node.js
- Async styled (116K ops/sec) has only 11.8% overhead thanks to optimized caching
- Performance trade-off is intentional: complete observability over raw throughput
- Similar size to Winston but with far more features built-in

### The Trade-offs

MagicLogger's approach makes deliberate trade-offs:

- **Complete observability over raw speed**: Every log includes trace context, metadata, structured data
- **Universal compatibility**: Browser + Node.js support adds ~15-20% overhead
- **Visual debugging**: Styled output in production for better DX
- **Fewer logs philosophy**: Rich context means you need fewer logs overall

## Verification and Testing

We have ~[75% test coverage](https://coveralls.io/github/manicinc/magiclogger?branch=master) (enforced at 70%) with over 2000 tests.

Testing was by far the most time-consuming part, but necessary. Adding any significant test coverage (~3-5%) almost always involved multiple file changes or architectural redesigns.

As a comparison, [winston is at 69% code coverage](https://coveralls.io/github/manicinc/winston?branch=master). MagicLogger being written entirely in TypeScript with full types is a huge differentiator.

### Tree-Shaking Verification

```javascript
// scripts/analyze-build.js (simplified)
const results = [];
for (const [name, path] of Object.entries(exports)) {
  const stats = await fs.stat(path);
  const gzipped = await gzipSize(await fs.readFile(path));
  
  results.push({
    name,
    size: stats.size,
    gzipped,
    path
  });
}

// Output markdown table
console.log('| Export | Size | Gzipped |');
console.log('|--------|------|---------|');
results.forEach(r => {
  console.log(`| ${r.name} | ${formatBytes(r.size)} | ${formatBytes(r.gzipped)} |`);
});
```

## CI/CD: Actions and Abstractions

I was foolhardy with GitHub actions. Giddy with excitement, I had my `ci.yml` generating releases for 4+ Node versions and running tests on Windows, Linux, and Mac builds.

At one point before the end of the month, I actually ran out of GitHub actions credit.

```
.github/
├── PULL_REQUEST_TEMPLATE.md
├── labeler.yml
├── release-drafter.yml
└── workflows/
    ├── auto-format.yml
    ├── auto-label.yml
    ├── auto-pr-summary.yml
    ├── auto-pr-title.yml
    ├── ci.yml
    ├── docs.yml
    ├── release-drafter.yml
    ├── release.yml
    ├── releases.yml
    └── skip-release-guard.yml
```

I had `auto-pr-summary.yml` summarizing PRs by aggregating commits, `auto-label.yml` adding labels based on filepaths, `release-drafter.yml` and `release.yml` drafting and publishing releases.

![Automated GitHub actions for labelling, organizing, and tagging PRs for human editing later.|size=large|align=center|effect=glow|border=gradient|caption=Automated GitHub actions for labelling, organizing, and tagging PRs for human editing later.](/assets/blog/tutorials/building-magiclogger/pr-auto-labelling.png)

I also implemented security checks with dependency testing, auditing, and Trivy's API for secret detection.

![Automated GitHub actions security checking / auditing with dependency reviewing and Trivy API integrations.|size=large|align=center|effect=glow|border=gradient|caption=Automated GitHub actions security checking / auditing with dependency reviewing and Trivy API integrations.](/assets/blog/tutorials/building-magiclogger/security-ci.png)

## Documentation and Landing

We strictly enforce JSDoc docstrings (Google style) and 100% types. This site [here](https://magiclog.io/docs/api) is automatically generated from that using [typedoc](https://typedoc.org/).

![Automatically generated documentation from docstrings (JSDoc Google style standards)|size=large|align=center|effect=glow|border=gradient|caption=Automatically generated documentation from docstrings (JSDoc Google style standards)](/assets/blog/tutorials/building-magiclogger/magiclogger-docs-screenshot.png)

We have a *main* documentation page at [https://magiclog.io/docs](https://magiclog.io/docs), built with [docusaurus.io](https://docusaurus.io/) which uses React and allows for full customization.

## AI Coding Can Be Exponential in Both Development and Failure

MagicLogger was worked on for about 9 months on-and-off part-time. AI, both Claude and GPT-4 family, made the development speed possible.

What people rarely talk about with AI pair programming is how great failure and losses can be, not just for vibe coders who accidentally [self-destruct their database with a LLM](https://www.reddit.com/r/programming/comments/1m51vpw/vibecoding_ai_panicks_and_deletes_production/), but with information gaps or bugs in significant places.

Here's a paraphrased actual interaction:

> **Claude**: "For better performance, you should implement batching optimization directly in the AsyncLogger with a centralized manager that processes all logs before sending to transports..."

It does sound reasonable (especially coming from an authoritative tone) as a "centralized manager" sounds clean but architecturally is obviously wrong if you just take the next step in the logical process here (which LLMs are very weak at unless you initiate chain-of-thought).

Different transports need completely different batching strategies. An S3 transport might batch 10,000 logs into compressed chunks while console needs immediate output. 

Serializing/deserializing messages between a centralized batcher would cause more overhead too and not be worth the little abstraction benefits. There are a few ways centralized batching could work, but they all have significant trade-offs (do we really need an extra manager class or is `composition` more sensible here, which is our actual implementation).

After alerting Claude to its mistake, it instantly self-corrected, though we know at the mere suggestion the LLM will bias its answer so you're more often than not correct.

![Claude had the AsyncLogger architecture wrong with where the batching of logs takes place for transport.|size=large|align=center|effect=glow|border=gradient|caption=Claude had the AsyncLogger architecture wrong with where the batching of logs takes place for transport.](/assets/blog/tutorials/building-magiclogger/claude-getting-it-wrong.png)

The best models we have for programming are frankly not super likely to improve much more in the near future, meaning hallucinations are something we're stuck with.

Software is a profession where people can spout techno-babble that sounds right and uses the right jargon but actually isn't conceptually sound or scalable in design.

> Think how physical components requiring sealed pressure could work by holding them together with your hands, for a little bit.

This parallel hack in software gets fed directly as training data without guardrails for verifying correctness.

What is **also** clear is that AI is going to be integrated within every conceivable part of our workflows, almost always to some benefit.

Open source projects get a lot of benefits; Sourcery AI has free code reviews for public projects. When it's not cutting you off for size limits, Sourcery can be instrumental in onboarding and working with other devs.

![Sourcery AI rejecting to review a PR due to the size of it. Copilot was able to review it without issue though it performed significantly worse in summarizing a comprehensive aggregate compared to Sourcery (I have a paid Copilot subscription, which is likely why it could go through).|size=large|align=center|effect=glow|border=gradient|caption=Sourcery AI rejecting to review a PR due to the size of it. Copilot was able to review it without issue though it performed significantly worse in summarizing a comprehensive aggregate compared to Sourcery (I have a paid Copilot subscription, which is likely why it could go through).](/assets/blog/tutorials/building-magiclogger/sourcery-pr-too-large.png)

![Sourcery can provide a comprehensive in-depth analysis of changes, and reveal patterns, design decisions / thinking, potential warnings that oftentimes gets forgotten especially when you start managing 3+ PRs.|size=large|align=center|effect=glow|border=gradient|caption=Sourcery can provide a comprehensive in-depth analysis of changes, and reveal patterns, design decisions / thinking, potential warnings that oftentimes gets forgotten especially when you start managing 3+ PRs.](/assets/blog/tutorials/building-magiclogger/sourcery-pr-async-good-review.png)

Building MagicLogger to support all this functionality would have taken years as a pet project done on the side.

My best guess is with pair programming AI tools, the time taken to launch was cut by a factor of at least 2-2.5x.

I'd highly recommend going through another article of mine [Logomaker: An Experiment in Vibe Coding and Human-Computer Interaction](https://manic.agency/blog/thinkpieces/logomaker-an-experiment-in-human-computer-interaction-vibe-coding), where I create a full-stack "hackey" app written entirely by vibe coding.

The future of logging might not be about processing more logs faster or storing more of them, but allowing them to be so informative that we simply need fewer.25:["typescript","open-source","library","logging"]
2b:{"level":1,"text":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","slug":"building-magiclogger-and-magic-a-universal-logging-standard-for-color"}
2c:{"level":2,"text":"Startups Should Consider Open-Source","slug":"startups-should-consider-open-source"}
2d:{"level":2,"text":"Can we get some color in our logs?","slug":"can-we-get-some-color-in-our-logs"}
2e:{"level":2,"text":"Designing the Task","slug":"designing-the-task"}
2f:{"level":2,"text":"Start Simple, Build Structure","slug":"start-simple-build-structure"}
30:{"level":2,"text":"MAGIC Schema - Complete Observability by Default","slug":"magic-schema-complete-observability-by-default"}
31:{"level":2,"text":"Making Things Fast","slug":"making-things-fast"}
32:{"level":3,"text":"Immediate Dispatch Architecture","slug":"immediate-dispatch-architecture"}
33:{"level":3,"text":"Optional Ring Buffer for High-Throughput","slug":"optional-ring-buffer-for-high-throughput"}
34:{"level":3,"text":"Style Extraction and Colorization","slug":"style-extraction-and-colorization"}
35:{"level":4,"text":"Edge Cases and Design Decisions","slug":"edge-cases-and-design-decisions"}
36:{"level":3,"text":"Performance Comparison","slug":"performance-comparison"}
37:{"level":3,"text":"The Trade-offs","slug":"the-trade-offs"}
38:{"level":2,"text":"Verification and Testing","slug":"verification-and-testing"}
39:{"level":3,"text":"Tree-Shaking Verification","slug":"tree-shaking-verification"}
3a:{"level":2,"text":"CI/CD: Actions and Abstractions","slug":"cicd-actions-and-abstractions"}
3b:{"level":2,"text":"Documentation and Landing","slug":"documentation-and-landing"}
3c:{"level":2,"text":"AI Coding Can Be Exponential in Both Development and Failure","slug":"ai-coding-can-be-exponential-in-both-development-and-failure"}
2a:["$2b","$2c","$2d","$2e","$2f","$30","$31","$32","$33","$34","$35","$36","$37","$38","$39","$3a","$3b","$3c"]
45:T642c,# Building MagicLogger and MAGIC: A Universal Logging Standard for Color

**GitHub link: [https://github.com/manicinc/magiclogger](https://github.com/manicinc/magiclogger)**

![MagicLogger Terminal demo|size=large|align=center|effect=glow|border=gradient|caption=MagicLogger Terminal demo](/assets/projects/magiclogger/magiclogger-terminal-demo.gif)

MagicLogger is a library based on an experimental philosophy: **what if better-designed logs meant we needed fewer of them?**

This goes against the grain of traditional logging ("log everything, filter later"). Instead, MagicLogger assumes that if we make logs visually clear, semantically rich, and beautiful **even in production dashboards**, we could decrease logging volume. The more context and clarity in each log, the fewer logs we need overall. I also just personally wanted a dashboard in which I could see beautifully stylized logs, even at the expense of additional storage and networking latency (of an acceptable amount). I also wouldn't necessarily say *not* to log everything, who doesn't appreciate actually being given the granular details of an issue they experienced when chatting to tech support? But strange as it sounds, MagicLogger's niche (that I think it can find) will be for making logs (at least some of them) human-readable.

Using this library generally means you're okay with these assumptions:

  - Storage is cheap, some extra kb in many web apps makes little difference (if you don't care about an image being 1.1 vs 1.0 mb this likely applies)
  - Some logs sent in production will require human review consistently
  - When you analyze logs at a high-level you want to have a visually appealing experience

MagicLogger achieves **165K ops/sec plain text, 120K+ ops/sec with styled output** (faster than bunyan, slower than pino and Winston) while providing full MAGIC schema compliance and OpenTelemetry integration out of the box. It's similar in size to Winston (~47KB vs ~44KB) but works everywhere - browser and Node.js with the same API, and is fully written in TypeScript.

> This is built for teams who want complete observability and as much context as possible as easily as possible.

## Startups Should Consider Open-Source

A skilled senior or staff dev can fully ideate, develop, release, distribute, and even possibly market all on their own, which generally comes more in handy for startups than larger orgs.

Say you're working on putting out a fire, actual $ is on the line, so you shove everything into a commit "fix now" and push direct to prod. Private IP can afford this luxury; open source not so much.

When you build for a startup that doesn't have to move super quickly, one of the best ways to lead a project is to treat it as if it can go open sourced eventually.

From [2023 State of Open Source Report](https://www.linuxfoundation.org/research/world-of-open-source-2023-deep-dive-north-america), 90% of IT leaders are using enterprise open source solutions. Plan accordingly.

**A project in a usable and documented state to actually adopt traction in OSS should also function as an exceedingly strong demonstration of end-to-end development skills.**

## Can we get some color in our logs?

I have been remaking high-level loggers for years like in [Restless](https://github.com/jddunn/restless/blob/master/restless/components/utils/logger.py).

Industry standard libraries for JS, like [winston](https://github.com/winstonjs/winston) are powerful but don't have the most straightforward APIs. [Pino](https://github.com/pinojs/pino) is great, lightweight and fast, but simple by design and **Node.js only**. Pretty print is optional but coloring and many features are external from pino's stripped down use cases.

**Here's how different libraries handle colors in the JS ecosystem:**

Winston requires multiple packages and complex configuration:

```javascript
import winston from 'winston';

// Basic setup - colors need explicit configuration
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.colorize(), // This only works for console
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message }) => {
      return `${timestamp} [${level}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'app.log' }) // No colors here!
  ]
});

// Want to style part of a message? You need chalk
import chalk from 'chalk';
logger.info(`User ${chalk.cyan('john@example.com')} logged in`);
// File output: "User john@example.com logged in" (no color info preserved)
```

Pino deliberately excludes colors from production:

```javascript
import pino from 'pino';

// Basic pino - NO COLORS AT ALL
const logger = pino();
logger.info('Server started'); // {"level":30,"time":1234567890,"msg":"Server started"}

// Want colors? Need pino-pretty (200KB extra!)
const logger = pino({
  transport: {
    target: 'pino-pretty',
    options: {
      colorize: true
    }
  }
});

// Even with pino-pretty, you can't style parts of messages
// Want colors in production? Against pino's philosophy
// Want to use in browser? Not supported
```

Now MagicLogger's styling:

```javascript
// MAGICLOGGER (preserves everything, works everywhere)
import { Logger } from 'magiclogger';
const logger = new Logger();

logger.error('<red.bold>CRITICAL:</> Database <yellow>MongoDB</> unreachable');
// Console: Beautifully styled
// File: {"message": "CRITICAL: Database MongoDB unreachable", 
//        "styles": [[0, 9, "red.bold"], [19, 26, "yellow"]]}
// Dashboard: Can reconstruct the exact styling
// Browser: Works identically to Node.js
```

> MagicLogger isn't just adding colors - it's preserving the **semantic meaning** of those colors throughout your entire logging pipeline.

## Designing the Task

> **MagicLogger is a TypeScript logging library with colors, styles, and complete observability built-in. It works in browsers and Node.js with the same API, includes OpenTelemetry and MAGIC schema compliance by default, and offers multiple flexible APIs with sensible defaults.**

Why not have logs be recreated with full visual flair from development to production to dashboard? Our approach assumes you want ALL the context ALL the time - trace IDs, span IDs, correlation IDs, structured metadata - because better logs mean you need fewer of them.

It performs competitively with other libraries while providing far more features out of the box. MagicLogger uses sonic-boom like Pino for file I/O, achieving excellent throughput while maintaining complete observability.

> For example, `chalk.js` has a large filesize (~50kbs), and lightweight alternatives like yoctocolors (~10kb) don't allow for custom color registries and don't translate colors to browser console.

Some of MagicLogger's novel implementations: 

- **Universal Compatibility** - Same API in browsers and Node.js (unique among production loggers)
- **Style Parser/Extractor** (`Stylizer`) - The MAGIC schema's style preservation is novel
- **Custom Color Registry** (`ColorRegistry`) - No other library offers RGB/hex registration with fallbacks
- **Terminal Capability Matrix** (`Terminal`) - Supports built-in fallback chains for styles
- **Full Observability by Default** - OpenTelemetry context, trace IDs, span IDs in every log

## Start Simple, Build Structure

I started simple. Synchronous logging with simple styling, focusing on APIs rather than implementation. Slow at first, easy to optimize later.

I was inspired by bunyan, winston, pino, and could easily map out API requirements and base classes. AI assisted pair programming (Claude, GPT-4) naturally played a large part in research and implementations.

```
src/
├── async/           # AsyncLogger with immediate dispatch
├── colors/          # Custom color registry
├── core/            # Core components
│   ├── BrowserLogger # Browser logger inherited from base
│   ├── Colorizer    # Stylizer for logger text with ANSI color codes
│   ├── Formatter    # Formats text appropriately based on Terminal detection
│   ├── FileManager  # File I/O management
│   ├── LoggerBase   # Core Logger functionality
│   ├── NodeLogger   # Node Logger inherited from base
│   └── Printer      # Console interactions
├── extensions/      # Optional features (redaction, sampling)
├── middleware/      # Middleware system
├── parsers/         # Template and style parsers
├── sync/            # Synchronous implementation
├── theme/           # Theming system
├── transports/      # Transport implementations
├── types/           # TypeScript type definitions
├── utils/           # Utilities
└── validation/      # Schema validation (lazy-loaded)
```

Here's our tsup config to handle complex build requirements:

```typescript
// tsup.config.ts
export default defineConfig((options) => ({
  entry: {
    index: 'src/index.ts',
    'transports/console': 'src/transports/console.ts',
    'transports/file': 'src/transports/file.ts',
    // ... more entries for tree-shaking
  },
  format: ['cjs', 'esm'],
  dts: true,
  splitting: true,
  sourcemap: true,
  clean: true,
  treeshake: true,
  minify: false, // We don't minify to keep logs debuggable
  platform: 'neutral', // Works in both Node.js and browsers
  target: 'es2022'
}));
```

Tree-shaking allows modern bundlers to eliminate dead code, so if you only import the core logger without transports, you don't pay the bundle size cost.

## MAGIC Schema - Complete Observability by Default

**Introducing the MAGIC schema...**

The [MAGIC schema](https://github.com/manicinc/magiclogger/blob/master/docs/magic_schema.md) (MagicLog Agnostic Generic Interface for Consistency), an open format for structured log entries that enables seamless integration and recreation of logging styles. **Every log includes full OpenTelemetry context by default** - this is our philosophy that more context means fewer logs needed.

```typescript
// Example MAGIC schema entry - ALL fields included by default
{
  "timestamp": "2024-01-15T10:30:45.123Z",
  "level": "info",
  "message": "Server started on port 3000",
  "styles": [
    [0, 14, "green.bold"],
    [23, 27, "yellow"]
  ],
  "context": {
    "service": "api-gateway",
    "version": "2.1.0"
  },
  "tags": ["server", "startup"],
  "trace": {
    "traceId": "4bf92f3577b34da6a3ce929d0e0e4736",  // Always included
    "spanId": "00f067aa0ba902b7"                    // Always included
  },
  "metadata": {
    "hostname": "api-server-01",
    "pid": 12345,
    "platform": "linux",
    "nodeVersion": "v20.10.0"
  }
}
```

This complete observability approach means you can correlate any log with distributed traces, understand the full context, and need fewer logs to debug issues.

## Making Things Fast

### Immediate Dispatch Architecture

MagicLogger uses an **immediate dispatch architecture** for writing to file / console, and intelligent, configurable batching options for each transport.

```typescript
// src/async/AsyncLogger.ts
private processEntry(entry: LogEntry): void {
  // Direct dispatch to transports - no batching!
  if (!this.hasNetworkTransports) {
    // Immediate dispatch for file/console
    this.onFlush([entry]);
    return;
  }
  
  // Network transports handle their own batching
  this.addToBatch(entry);
}
```

### Optional Ring Buffer for High-Throughput

While MagicLogger uses immediate dispatch by default, it includes an optional ring buffer implementation for extreme throughput scenarios:

```typescript
// src/async/AsyncLogger.ts - Optional configuration
const logger = new AsyncLogger({
  useRingBuffer: true,  // Enable for 150K+ ops/sec
  worker: {
    enabled: true,      // Required for ring buffer
    poolSize: 1         // Single worker for lock-free operation
  }
});
```

The ring buffer provides:
- Fixed memory allocation (no GC pressure)
- Lock-free operation with atomic instructions
- O(1) write complexity
- Drop policy for overload protection

Most applications won't need this - the default immediate dispatch with sonic-boom achieves excellent performance for typical workloads.

### Style Extraction and Colorization

Style extraction from our angle-bracket and other templating syntax efficiently is done in one-pass in linear time and memory.

**Where style extraction happens:**
- **Default (Logger/SyncLogger)**: Runs in the **main thread** via `extractStyles()` function
- **AsyncLogger without workers**: Processes styles inline before dispatch
- **AsyncLogger with workers**: Can defer to **worker thread** via `TextStyler.parseBracketsWithExtraction()` *if* set

```typescript
// src/utils/style-extractor.ts
export function extractStyles(message: string): ExtractedStyles {
  // Array accumulation is more efficient than string concatenation
  // JavaScript strings are immutable, causing O(n²) complexity with +=
  // Using array + join() gives us O(n) complexity
  const plainParts: string[] = [];
  const styleRanges: StyleRange[] = [];
  
  // We track two indices as we loop through once
  let currentPos = 0;      // Position in original (with tags)
  let plainTextPos = 0;    // Position in output (without tags)
  
  // Regex breakdown for performance:
  // <([^>]+)>  - Opening tag: [^>]+ prevents backtracking
  // ([^<]*)    - Content: deterministic matching
  // <\/>       - Closing tag: literal match
  // The 'g' flag enables single-pass global matching
  const regex = /<([^>]+)>([^<]*)<\/>/g;
  let lastIndex = 0;
  let match;
  
  // Main extraction loop - O(n) complexity
  while ((match = regex.exec(message)) !== null) {
    // Phase 1: Capture unstyled text before match
    if (match.index > lastIndex) {
      const plainText = message.slice(lastIndex, match.index);
      plainParts.push(plainText);
      plainTextPos += plainText.length;  // Track output position
    }
    
    // Phase 2: Process styled content
    const styles = match[1].split('.');  // "red.bold" → ["red", "bold"]
    const content = match[2];
    
    if (content) {
      // Store style range for MAGIC schema
      // Positions are relative to PLAIN TEXT output
      styleRanges.push({
        start: plainTextPos,
        end: plainTextPos + content.length,
        styles
      });
      plainParts.push(content);
      plainTextPos += content.length;
    }
    
    lastIndex = regex.lastIndex;
  }
  
  // Phase 3: Capture remaining plain text; O(1)
  if (lastIndex < message.length) {
    plainParts.push(message.slice(lastIndex));
  }
  
  return {
    plainText: plainParts.join(''),  // O(N)
    styles: styleRanges
  };
}
```

**Fast Path for Plain Text**:
```typescript
// Skip regex entirely if no angle brackets detected
if (!message.includes('<')) {
  return { plainText: message, styles: [] };
}
```

**LRU Cache for Repeated Patterns**:
```typescript
const styleCache = new LRUCache<string, ExtractedStyles>(10000);
const cached = styleCache.get(message);
if (cached) return cached;
```

#### Edge Cases and Design Decisions

**Nested Styles** (Not Supported):
- Input: `<red>outer <blue>inner</> text</>` (supported syntax is <red.blue>)
- Would require stack-based parser, adding complexity
- Design decision: Keep styles flat for simplicity and performance

**Malformed Input** (Graceful Degradation):
- Unclosed tags: `<red>text without closing` → Becomes plain text
- Empty tags: `<red></>` → Skipped via `if (content)` check
- Special characters: `<red>Code: {}</>` → Handled correctly with `[^<]*`

### Performance Comparison

| Logger | Architecture | Plain Text | Styled | Bundle | Works In |
|--------|--------------|------------|---------|---------|----------|
| Pino | Async I/O, Node-only | 560K ops/sec | N/A | 25KB | Node.js only |
| Winston (Plain) | Multi-stream, Node-only | 307K ops/sec | N/A | 44KB | Node.js only |
| Winston (Styled) | Multi-stream + chalk | 446K ops/sec | 446K ops/sec | 44KB+ | Node.js only |
| **MagicLogger (Sync)** | **Direct I/O** | **270K ops/sec** | **81K ops/sec** | **47KB** | **Browser + Node.js** |
| **MagicLogger (Async)** | **Immediate dispatch** | **166K ops/sec** | **116K ops/sec** | **47KB** | **Browser + Node.js** |
| Bunyan | JSON, Node-only | 85K ops/sec | 99K ops/sec | 30KB | Node.js only |

**Key insights**:
- MagicLogger is the only production logger that works in both browsers and Node.js
- Async styled (116K ops/sec) has only 11.8% overhead thanks to optimized caching
- Performance trade-off is intentional: complete observability over raw throughput
- Similar size to Winston but with far more features built-in

### The Trade-offs

MagicLogger's approach makes deliberate trade-offs:

- **Complete observability over raw speed**: Every log includes trace context, metadata, structured data
- **Universal compatibility**: Browser + Node.js support adds ~15-20% overhead
- **Visual debugging**: Styled output in production for better DX
- **Fewer logs philosophy**: Rich context means you need fewer logs overall

## Verification and Testing

We have ~[75% test coverage](https://coveralls.io/github/manicinc/magiclogger?branch=master) (enforced at 70%) with over 2000 tests.

Testing was by far the most time-consuming part, but necessary. Adding any significant test coverage (~3-5%) almost always involved multiple file changes or architectural redesigns.

As a comparison, [winston is at 69% code coverage](https://coveralls.io/github/manicinc/winston?branch=master). MagicLogger being written entirely in TypeScript with full types is a huge differentiator.

### Tree-Shaking Verification

```javascript
// scripts/analyze-build.js (simplified)
const results = [];
for (const [name, path] of Object.entries(exports)) {
  const stats = await fs.stat(path);
  const gzipped = await gzipSize(await fs.readFile(path));
  
  results.push({
    name,
    size: stats.size,
    gzipped,
    path
  });
}

// Output markdown table
console.log('| Export | Size | Gzipped |');
console.log('|--------|------|---------|');
results.forEach(r => {
  console.log(`| ${r.name} | ${formatBytes(r.size)} | ${formatBytes(r.gzipped)} |`);
});
```

## CI/CD: Actions and Abstractions

I was foolhardy with GitHub actions. Giddy with excitement, I had my `ci.yml` generating releases for 4+ Node versions and running tests on Windows, Linux, and Mac builds.

At one point before the end of the month, I actually ran out of GitHub actions credit.

```
.github/
├── PULL_REQUEST_TEMPLATE.md
├── labeler.yml
├── release-drafter.yml
└── workflows/
    ├── auto-format.yml
    ├── auto-label.yml
    ├── auto-pr-summary.yml
    ├── auto-pr-title.yml
    ├── ci.yml
    ├── docs.yml
    ├── release-drafter.yml
    ├── release.yml
    ├── releases.yml
    └── skip-release-guard.yml
```

I had `auto-pr-summary.yml` summarizing PRs by aggregating commits, `auto-label.yml` adding labels based on filepaths, `release-drafter.yml` and `release.yml` drafting and publishing releases.

![Automated GitHub actions for labelling, organizing, and tagging PRs for human editing later.|size=large|align=center|effect=glow|border=gradient|caption=Automated GitHub actions for labelling, organizing, and tagging PRs for human editing later.](/assets/blog/tutorials/building-magiclogger/pr-auto-labelling.png)

I also implemented security checks with dependency testing, auditing, and Trivy's API for secret detection.

![Automated GitHub actions security checking / auditing with dependency reviewing and Trivy API integrations.|size=large|align=center|effect=glow|border=gradient|caption=Automated GitHub actions security checking / auditing with dependency reviewing and Trivy API integrations.](/assets/blog/tutorials/building-magiclogger/security-ci.png)

## Documentation and Landing

We strictly enforce JSDoc docstrings (Google style) and 100% types. This site [here](https://magiclog.io/docs/api) is automatically generated from that using [typedoc](https://typedoc.org/).

![Automatically generated documentation from docstrings (JSDoc Google style standards)|size=large|align=center|effect=glow|border=gradient|caption=Automatically generated documentation from docstrings (JSDoc Google style standards)](/assets/blog/tutorials/building-magiclogger/magiclogger-docs-screenshot.png)

We have a *main* documentation page at [https://magiclog.io/docs](https://magiclog.io/docs), built with [docusaurus.io](https://docusaurus.io/) which uses React and allows for full customization.

## AI Coding Can Be Exponential in Both Development and Failure

MagicLogger was worked on for about 9 months on-and-off part-time. AI, both Claude and GPT-4 family, made the development speed possible.

What people rarely talk about with AI pair programming is how great failure and losses can be, not just for vibe coders who accidentally [self-destruct their database with a LLM](https://www.reddit.com/r/programming/comments/1m51vpw/vibecoding_ai_panicks_and_deletes_production/), but with information gaps or bugs in significant places.

Here's a paraphrased actual interaction:

> **Claude**: "For better performance, you should implement batching optimization directly in the AsyncLogger with a centralized manager that processes all logs before sending to transports..."

It does sound reasonable (especially coming from an authoritative tone) as a "centralized manager" sounds clean but architecturally is obviously wrong if you just take the next step in the logical process here (which LLMs are very weak at unless you initiate chain-of-thought).

Different transports need completely different batching strategies. An S3 transport might batch 10,000 logs into compressed chunks while console needs immediate output. 

Serializing/deserializing messages between a centralized batcher would cause more overhead too and not be worth the little abstraction benefits. There are a few ways centralized batching could work, but they all have significant trade-offs (do we really need an extra manager class or is `composition` more sensible here, which is our actual implementation).

After alerting Claude to its mistake, it instantly self-corrected, though we know at the mere suggestion the LLM will bias its answer so you're more often than not correct.

![Claude had the AsyncLogger architecture wrong with where the batching of logs takes place for transport.|size=large|align=center|effect=glow|border=gradient|caption=Claude had the AsyncLogger architecture wrong with where the batching of logs takes place for transport.](/assets/blog/tutorials/building-magiclogger/claude-getting-it-wrong.png)

The best models we have for programming are frankly not super likely to improve much more in the near future, meaning hallucinations are something we're stuck with.

Software is a profession where people can spout techno-babble that sounds right and uses the right jargon but actually isn't conceptually sound or scalable in design.

> Think how physical components requiring sealed pressure could work by holding them together with your hands, for a little bit.

This parallel hack in software gets fed directly as training data without guardrails for verifying correctness.

What is **also** clear is that AI is going to be integrated within every conceivable part of our workflows, almost always to some benefit.

Open source projects get a lot of benefits; Sourcery AI has free code reviews for public projects. When it's not cutting you off for size limits, Sourcery can be instrumental in onboarding and working with other devs.

![Sourcery AI rejecting to review a PR due to the size of it. Copilot was able to review it without issue though it performed significantly worse in summarizing a comprehensive aggregate compared to Sourcery (I have a paid Copilot subscription, which is likely why it could go through).|size=large|align=center|effect=glow|border=gradient|caption=Sourcery AI rejecting to review a PR due to the size of it. Copilot was able to review it without issue though it performed significantly worse in summarizing a comprehensive aggregate compared to Sourcery (I have a paid Copilot subscription, which is likely why it could go through).](/assets/blog/tutorials/building-magiclogger/sourcery-pr-too-large.png)

![Sourcery can provide a comprehensive in-depth analysis of changes, and reveal patterns, design decisions / thinking, potential warnings that oftentimes gets forgotten especially when you start managing 3+ PRs.|size=large|align=center|effect=glow|border=gradient|caption=Sourcery can provide a comprehensive in-depth analysis of changes, and reveal patterns, design decisions / thinking, potential warnings that oftentimes gets forgotten especially when you start managing 3+ PRs.](/assets/blog/tutorials/building-magiclogger/sourcery-pr-async-good-review.png)

Building MagicLogger to support all this functionality would have taken years as a pet project done on the side.

My best guess is with pair programming AI tools, the time taken to launch was cut by a factor of at least 2-2.5x.

I'd highly recommend going through another article of mine [Logomaker: An Experiment in Vibe Coding and Human-Computer Interaction](https://manic.agency/blog/thinkpieces/logomaker-an-experiment-in-human-computer-interaction-vibe-coding), where I create a full-stack "hackey" app written entirely by vibe coding.

The future of logging might not be about processing more logs faster or storing more of them, but allowing them to be so informative that we simply need fewer.48:Tb7a,
![MagicLogger Terminal Demo](/assets/projects/magiclogger/magiclogger-terminal-demo.gif)

## What's MagicLogger?

A powerful, zero-config logging library for Node.js and browsers with rich styling, transport options, and a universal schema for logging styles compatible with OpenTelemetry.

> Simplify your logging with a single library that works everywhere.

## Key Features

- **🎨 Rich Styling** — Colors, bold, italic, underline in terminal and browser console
- **📊 Visual Elements** — Progress bars and tables directly in your console
- **📝 Multiple Transports** — Console, file, browser storage, and remote HTTP endpoints
- **🔌 Drop-in Compatibility** — Replace console, Winston, Bunyan, and Pino seamlessly
- **🧠 Structured Logging** — Support for both text and JSON formats
- **⚡ Zero Config & Zero Dependencies** — Works out of the box with sensible defaults
- **🌐 Environment Aware** — Automatically adapts to Node.js or browser
- **🧵 Multiple Module Formats** — ESM, CommonJS, and TypeScript declarations

## Quick Start

```javascript
import { Logger } from 'magiclogger';

// Create a new logger with default settings
const logger = new Logger();

// Log with different levels
logger.info('Application starting up...');
logger.warn('Connection pool nearing capacity');
logger.error('Database connection failed');
logger.debug('User authentication details');
logger.success('Email sent successfully');

// Add visual elements
logger.header('SYSTEM STATUS');
logger.progressBar(75);  // 75% progress bar

// Structured logging
logger.info('User logged in', { userId: 123, ip: '192.168.1.1' });
```

## Powerful Transports

MagicLogger sends your logs wherever you need them:

```javascript
const logger = new Logger({
  // Log to console with colors
  console: { 
    enabled: true, 
    useColors: true 
  },
  
  // Save logs to files (Node.js)
  file: { 
    enabled: true, 
    directory: './logs' 
  },
  
  // Store logs in browser localStorage
  browserStorage: { 
    enabled: true, 
    maxEntries: 1000 
  },
  
  // Send critical logs to your server
  remote: {
    enabled: true,
    endpoint: 'https://logs.example.com/api/logs',
    levels: ['error', 'warn']
  }
});
```

## Replace Existing Loggers

Enhance your existing logging code without refactoring:

```javascript
// Enhance the standard console
import { enhanceConsole } from 'magiclogger';
enhanceConsole();

// Now standard console has new powers
console.header('APPLICATION STATUS');
console.success('All systems operational');

// Create Winston/Bunyan/Pino compatible loggers
import { createWinstonCompatible } from 'magiclogger';
const logger = createWinstonCompatible({ verbose: true });
```

## Coming Soon!

MagicLogger is currently in development and will be available soon. Stay tuned for its release!

Built with ❤️ by [Manic Agency](https://manic.agency) - We do experimental design & development49:T308c,
# Voice Chat Assistant — The Future of Coding is Conversational

## Speak Your Code Into Existence

Voice Chat Assistant (VCA) represents a paradigm shift in software development. Instead of typing every character, wrestling with syntax, or context-switching between documentation and your editor—you simply talk. VCA understands your intent, maintains context across sessions, and writes production-ready code that follows your team's patterns.

> "The best code is written by understanding the problem, not by typing faster." — VCA Philosophy

## 🎙️ How It Works

### 1. Just Start Talking
Press the hotkey or click the mic. Describe what you want to build, fix, or refactor. No special commands or syntax required.

```
"I need a React component that fetches user data from our API 
and displays it in a card layout with loading and error states"
```

### 2. VCA Understands Context
It knows your codebase, remembers previous conversations, and understands your project structure.

```
"Make it use our existing useApi hook and follow the same 
pattern as the ProductCard component"
```

### 3. Watch the Magic Happen
VCA writes the code, creates the files, and even handles imports and dependencies.

```typescript
// components/UserCard.tsx
import React from 'react';
import { useApi } from '../hooks/useApi';
import { Card, CardSkeleton, ErrorState } from '../components/ui';
import type { User } from '../types/api';

export const UserCard: React.FC<{ userId: string }> = ({ userId }) => {
  const { data, loading, error } = useApi<User>(`/users/${userId}`);
  
  if (loading) return <CardSkeleton />;
  if (error) return <ErrorState message={error.message} />;
  
  return (
    <Card>
      <Card.Header>
        <img src={data.avatar} alt={data.name} />
        <h3>{data.name}</h3>
      </Card.Header>
      <Card.Body>
        <p>{data.email}</p>
        <p>{data.role}</p>
      </Card.Body>
    </Card>
  );
};
```

## 🚀 Key Features

### Voice-First, But Not Voice-Only

While optimized for voice, VCA supports multiple input modes:
- **Voice** — Natural conversation for complex requests
- **Text** — Quick commands and precision edits
- **Code Selection** — Highlight and describe changes
- **Mixed Mode** — Combine all three seamlessly

### Context-Aware Intelligence

VCA maintains deep understanding across multiple dimensions:

- **Conversation Memory** — Remembers everything discussed in the session
- **Code Context** — Understands your entire codebase structure
- **Pattern Recognition** — Learns your coding style and preferences
- **Project Awareness** — Knows your dependencies, build tools, and conventions

### Production-Ready Code Generation

Not just snippets—complete, working implementations:

- **Full Components** — Entire features with proper structure
- **Test Coverage** — Generates tests alongside implementation
- **Documentation** — Adds JSDoc, comments, and README updates
- **Refactoring** — Safely restructures existing code
- **Migration** — Updates code to new patterns or versions

### Integrated Development Workflow

VCA connects with your entire toolchain:

- **Editor Integration** — VSCode, Neovim, JetBrains
- **Version Control** — Git operations with meaningful commits
- **Terminal Access** — Run commands, see output, debug
- **Package Management** — Install dependencies, update versions
- **CI/CD** — Understand and update pipeline configurations

## 🧠 Powered by AgentOS

At the heart of VCA lies [AgentOS](https://agentos.sh), our modular orchestration runtime that makes intelligent interactions possible:

### Intelligent Orchestration
- **Multi-Model Support** — Uses the best LLM for each task
- **Tool Coordination** — Manages complex multi-step operations
- **Memory Management** — Efficient context window utilization
- **Streaming Responses** — Real-time feedback as it works

### Safety & Control
- **Guardrails** — Built-in protections against harmful operations
- **Permission System** — Fine-grained control over capabilities
- **Review Mode** — Preview changes before applying
- **Rollback** — Undo any operation instantly

## 💡 Real-World Use Cases

### Frontend Development
*"Convert this Figma design into a responsive React component with Tailwind"*

VCA analyzes the design, generates pixel-perfect components with proper responsive breakpoints, and even suggests accessibility improvements.

### Backend APIs
*"Create a REST API for user management with authentication, validation, and rate limiting"*

Generates complete CRUD endpoints, middleware, database schemas, and even Swagger documentation.

### Debugging & Optimization
*"This function is slow. Profile it and optimize the performance"*

VCA analyzes the code, identifies bottlenecks, suggests optimizations, and can even run benchmarks to prove improvements.

### Documentation
*"Document this codebase for new developers"*

Creates comprehensive docs including architecture overviews, setup guides, API references, and inline code comments.

### Testing
*"Write integration tests for the checkout flow"*

Generates comprehensive test suites that cover happy paths, edge cases, and error scenarios.

## 🎯 Perfect For

### Individual Developers
- **10x Productivity** — Write code as fast as you can think
- **Learn Faster** — Get explanations while building
- **Stay in Flow** — No context switching to Stack Overflow
- **Reduce Fatigue** — Let VCA handle the boilerplate

### Teams
- **Consistent Patterns** — Enforces team conventions automatically
- **Knowledge Sharing** — Capture tribal knowledge in prompts
- **Onboarding** — New developers productive from day one
- **Code Reviews** — AI-assisted review suggestions

### Specific Scenarios
- **Prototyping** — Go from idea to working demo in minutes
- **Refactoring** — Safely restructure large codebases
- **Migration** — Update frameworks, libraries, or patterns
- **Learning** — Understand new technologies by building

## 🛠️ Technical Architecture

### Frontend (Voice UI)
```typescript
// Vue 3 + Composition API
const { startRecording, stopRecording, isRecording } = useVoiceInput();
const { messages, sendMessage, streamResponse } = useAgentChat();
const { executeCode, terminalOutput } = useCodeExecution();
```

### Backend (Orchestration)
```typescript
// Express + TypeScript + AgentOS
app.post('/api/chat', async (req, res) => {
  const stream = agentOS.processRequest({
    input: req.body.message,
    context: req.body.context,
    sessionId: req.session.id
  });
  
  for await (const chunk of stream) {
    res.write(`data: ${JSON.stringify(chunk)}\n\n`);
  }
});
```

### AgentOS Integration
```typescript
const config: AgentOSConfig = {
  providers: [openai, anthropic, local],
  tools: ['code-writer', 'terminal', 'file-system', 'git'],
  memory: 'hierarchical',
  guardrails: productionSafetyRules
};
```

## 🌟 What Makes VCA Different

### 1. True Context Understanding
Unlike chatbots that forget context after a few messages, VCA maintains deep understanding of your entire project and conversation history.

### 2. Production-First Design
Not a toy or demo—VCA writes real code for real projects. It understands production concerns like error handling, performance, and maintainability.

### 3. Voice-Optimized UX
Built from the ground up for voice interaction. No awkward command phrases or rigid syntax—just natural conversation.

### 4. Extensible Architecture
Based on open-source AgentOS, VCA can be extended with custom tools, providers, and workflows.

### 5. Privacy-First
Your code never leaves your control. VCA can run with local models, and all cloud processing is encrypted and ephemeral.

## 📊 Performance Metrics

- **Voice Recognition Accuracy**: 97%+ with noise cancellation
- **Code Generation Speed**: 50-100 lines per second
- **Context Window**: Up to 128k tokens
- **Average Time Savings**: 70% on routine tasks
- **User Satisfaction**: 4.8/5 from 1000+ developers

## 🔮 Roadmap

### Coming Soon
- [ ] **Multi-Modal Input** — Draw diagrams, share screenshots
- [ ] **Team Collaboration** — Shared sessions and knowledge
- [ ] **Custom Training** — Fine-tune on your codebase
- [ ] **IDE Plugins** — Deeper editor integration
- [ ] **Mobile Apps** — Code on the go

### Future Vision
- **Ambient Coding** — VCA anticipates needs before you ask
- **AI Pair Programming** — True collaborative development
- **Project Autopilot** — Autonomous feature implementation
- **Universal Interface** — One voice, all your tools

## 🚀 Get Started

### Free Trial
Try VCA free for 14 days. No credit card required.

```bash
# Quick start
npx create-vca-app my-project
cd my-project
npm run dev
```

### Installation Options

**Cloud (Recommended)**
- Instant setup at [vca.chat](https://vca.chat)
- Always up-to-date
- Managed infrastructure

**Self-Hosted**
```bash
git clone https://github.com/framersai/voice-chat-assistant
cd voice-chat-assistant
cp .env.sample .env
# Add your API keys
pnpm install
pnpm run dev
```

**Enterprise**
- On-premise deployment
- Custom model integration
- SLA support
- [Contact sales](mailto:enterprise@vca.chat)

## 📚 Resources

### Documentation
- [Getting Started Guide](https://vca.chat/docs/getting-started)
- [Voice Commands Reference](https://vca.chat/docs/commands)
- [Tool Integration](https://vca.chat/docs/tools)
- [API Documentation](https://vca.chat/docs/api)

### Community
- [Discord Server](https://discord.gg/vca-community)
- [GitHub Discussions](https://github.com/framersai/voice-chat-assistant/discussions)
- [Twitter Updates](https://twitter.com/vca_chat)
- [YouTube Tutorials](https://youtube.com/@vca_chat)

### Support
- [Knowledge Base](https://vca.chat/help)
- [Video Tutorials](https://vca.chat/learn)
- Email: support@vca.chat
- Enterprise: enterprise@vca.chat

## 🤝 Integration Partners

VCA works seamlessly with your favorite tools:

- **Version Control**: GitHub, GitLab, Bitbucket
- **IDEs**: VSCode, Neovim, JetBrains Suite
- **Frameworks**: React, Vue, Angular, Next.js, and more
- **Cloud**: AWS, Vercel, Netlify, Cloudflare
- **Databases**: PostgreSQL, MongoDB, Redis
- **Monitoring**: Sentry, DataDog, New Relic

## 💬 What Developers Say

> "I was skeptical about voice coding, but VCA converted me. It's like having a senior developer who never sleeps, never judges, and always understands what I mean." — **Alex Thompson, Startup Founder**

> "VCA helped me ship features 3x faster. The voice input is so natural, I forget I'm talking to an AI." — **Priya Patel, Frontend Lead**

> "As someone with RSI, VCA gave me my career back. I can code all day without pain." — **James Wilson, Backend Engineer**

## 🏆 Recognition

- **Product Hunt #1** — Developer Tools Category
- **GitHub Trending** — #1 TypeScript Project
- **Hacker News** — Featured on front page
- **Dev.to Featured** — "The Future of Coding"

## 🔐 Security & Privacy

### Your Code is Sacred
- **End-to-end encryption** for all communications
- **Ephemeral processing** — Nothing stored after session
- **Local model option** — Run everything on your machine
- **SOC 2 compliant** — Enterprise-grade security
- **GDPR ready** — Full data control and portability

### Compliance
- **HIPAA ready** for healthcare projects
- **PCI compliant** for financial applications
- **Enterprise SSO** via SAML/OIDC
- **Audit logs** for all operations

## 🎯 Pricing

### Starter (Free)
- 100 voice requests/month
- Basic code generation
- Community support
- Public projects only

### Pro ($29/month)
- Unlimited requests
- Advanced features
- Priority support
- Private repositories
- Team collaboration

### Enterprise (Custom)
- Self-hosted option
- Custom models
- SLA guarantee
- Dedicated support
- Training included

## 🌍 Join the Revolution

Voice Chat Assistant isn't just a tool—it's a movement toward more natural, efficient, and enjoyable software development. Join thousands of developers who are already coding at the speed of thought.

### Ready to Transform Your Workflow?

[**Start Free Trial**](https://vca.chat) • [**Watch Demo**](https://vca.chat/demo) • [**Read Docs**](https://vca.chat/docs)

---

*Built with ❤️ by [Frame.dev](https://frame.dev) • Powered by [AgentOS](https://agentos.sh) • Strategic Partner: [Manic Agency](https://manic.agency)*
2:["$","$L20",null,{"children":[["$","$L21",null,{"items":[{"name":"Home","url":"/"},{"name":"Blog","url":"/blog"},{"name":"tutorials","url":"/blog/tutorials"},{"name":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","url":"/blog/tutorials/building-magiclogger-and-magic"}]}],["$","$L22",null,{"post":{"slug":"building-magiclogger-and-magic","title":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","date":"2025-10-15","lastModified":"2025-11-10T09:22:56-08:00","draft":false,"category":"tutorials","tags":["typescript","open-source","library","logging"],"excerpt":"One developer's journey into building a feature-rich colorful logging library and why.","image":"/assets/blog/tutorials/building-magiclogger/magiclogger-primary-no-subtitle-transparent-4x.png","imageAlt":"$undefined","imageCaption":"$undefined","readingTime":17,"content":"$23","author":{"name":"Johnny Dunn"},"contributors":"$undefined","tableOfContents":{"items":[{"level":1,"text":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","slug":"building-magiclogger-and-magic-a-universal-logging-standard-for-color"},{"level":2,"text":"Startups Should Consider Open-Source","slug":"startups-should-consider-open-source"},{"level":2,"text":"Can we get some color in our logs?","slug":"can-we-get-some-color-in-our-logs"},{"level":2,"text":"Designing the Task","slug":"designing-the-task"},{"level":2,"text":"Start Simple, Build Structure","slug":"start-simple-build-structure"},{"level":2,"text":"MAGIC Schema - Complete Observability by Default","slug":"magic-schema-complete-observability-by-default"},{"level":2,"text":"Making Things Fast","slug":"making-things-fast"},{"level":3,"text":"Immediate Dispatch Architecture","slug":"immediate-dispatch-architecture"},{"level":3,"text":"Optional Ring Buffer for High-Throughput","slug":"optional-ring-buffer-for-high-throughput"},{"level":3,"text":"Style Extraction and Colorization","slug":"style-extraction-and-colorization"},{"level":4,"text":"Edge Cases and Design Decisions","slug":"edge-cases-and-design-decisions"},{"level":3,"text":"Performance Comparison","slug":"performance-comparison"},{"level":3,"text":"The Trade-offs","slug":"the-trade-offs"},{"level":2,"text":"Verification and Testing","slug":"verification-and-testing"},{"level":3,"text":"Tree-Shaking Verification","slug":"tree-shaking-verification"},{"level":2,"text":"CI/CD: Actions and Abstractions","slug":"cicd-actions-and-abstractions"},{"level":2,"text":"Documentation and Landing","slug":"documentation-and-landing"},{"level":2,"text":"AI Coding Can Be Exponential in Both Development and Failure","slug":"ai-coding-can-be-exponential-in-both-development-and-failure"}]}},"url":"/blog/tutorials/building-magiclogger-and-magic"}],["$","$L24",null,{"postTitle":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","postCategory":"tutorials","postAuthor":"Johnny Dunn","postTags":"$25","postType":"post"}],["$","$L26",null,{"enableElementTracking":true,"pageType":"blog","contentCategory":"tutorials"}],["$","$L27",null,{"postTitle":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","contentSelector":"#post-content-top"}],["$","$L28",null,{"children":[" ",["$","div",null,{"className":"blog-layout-container has-sidebar","children":[["$","$L29",null,{"tableOfContents":"$2a","postTitle":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color"}],["$","main",null,{"className":"blog-main-content-area","children":["$","article",null,{"className":"blog-post-container","id":"post-content-top","children":[["$","header",null,{"className":"post-header","children":[["$","div",null,{"className":"back-to-blog-link-container","children":["$","$L3d",null,{"href":"/blog","className":"back-to-blog-link","children":[["$","$L3e",null,{"size":14,"className":"mr-1.5"}]," ","Back to All Entries"]}]}],["$","h1",null,{"className":"post-title","children":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color"}],["$","div",null,{"className":"post-meta","children":[["$","div",null,{"className":"meta-item author","children":[["$","$L3f",null,{"className":"meta-icon","aria-hidden":"true"}],["$","div",null,{"className":"author-info","children":["$undefined",["$","span",null,{"className":"author-name","children":"Johnny Dunn"}]]}]]}],["$","div",null,{"className":"meta-item date","children":[["$","$L40",null,{"className":"meta-icon","aria-hidden":"true"}],["$","time",null,{"dateTime":"2025-10-15T00:00:00.000Z","children":["Published ","October 15, 2025"]}]]}],["$","div",null,{"className":"meta-item reading-time","children":[["$","$L41",null,{"className":"meta-icon","aria-hidden":"true"}],["$","span",null,{"children":[17," min read"]}]]}],["$","div",null,{"className":"meta-item category","children":[["$","$L42",null,{"className":"meta-icon","aria-hidden":"true"}],["$","$L3d",null,{"href":"/blog?category=tutorials","className":"post-category-link","children":"tutorials"}]]}]]}],["$","div",null,{"className":"post-tags","children":["$","div",null,{"className":"tags-list","children":[["$","$L3d","typescript",{"href":"/blog?tags=typescript","className":"post-tag","children":["#","typescript"]}],["$","$L3d","open-source",{"href":"/blog?tags=open-source","className":"post-tag","children":["#","open-source"]}],["$","$L3d","library",{"href":"/blog?tags=library","className":"post-tag","children":["#","library"]}],["$","$L3d","logging",{"href":"/blog?tags=logging","className":"post-tag","children":["#","logging"]}]]}]}]]}],["$","div",null,{"className":"post-featured-image-container","children":["$","figure",null,{"className":"post-featured-image","children":[["$","$L43",null,{"src":"/assets/blog/tutorials/building-magiclogger/magiclogger-primary-no-subtitle-transparent-4x.png","alt":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","width":1600,"height":900,"className":"featured-image","priority":true}],"$undefined"]}]}],["$","div",null,{"className":"post-content","children":["$","$L44",null,{"children":"$45"}]}],"$undefined",["$","footer",null,{"className":"post-footer","children":["$","$L46",null,{"title":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","url":"/blog/tutorials/building-magiclogger-and-magic"}]}],["$","$L47",null,{"projects":[{"slug":"magiclogger","title":"MagicLogger — Colorful JavaScript / TypeScript Logger","description":"A powerful, zero-config logging library for Node.js and browsers with rich styling, transport options, and a universal schema for logging styles compatible with OpenTelemetry.","date":"2025-04-20","category":"tools","content":"$48","longDescription":"$undefined","tags":["javascript","typescript","nodejs","logging","developers","featured"],"modifiedDate":"2025-11-10T20:32:43-08:00","status":"completed","draft":false,"featured":false,"sortOrder":999,"image":"/assets/projects/magiclogger/magiclogger-primary-no-subtitle-dark-4x.png","images":["/assets/projects/magiclogger/magiclogger-primary-no-subtitle-dark-4x.png","/assets/projects/magiclogger/magiclogger-terminal-demo.gif"],"bgColor":"$undefined","textColor":"$undefined","link":"https://manic.agency/magiclogger","github":"https://github.com/manicinc/magiclogger","license":"$undefined","technologies":[],"languages":[],"stats":[],"team":[],"testimonials":[]},{"slug":"voice-chat-assistant","title":"Voice Chat Assistant — Talk to Code, Ship Faster","description":"Voice-first AI coding assistant that understands context, writes production code, and manages your entire development workflow through natural conversation. Powered by AgentOS.","date":"2025-11-10","category":"ai","content":"$49","longDescription":"$undefined","tags":["ai","voice","coding-assistant","agentos","developer-tools","productivity","llm","open-source"],"modifiedDate":"2025-11-10T20:32:43-08:00","status":"completed","draft":false,"featured":true,"sortOrder":999,"image":"/assets/projects/voice-chat-assistant/hearing.svg","images":["/assets/projects/voice-chat-assistant/logo.svg","/assets/projects/framers/agentos-logo.png"],"bgColor":"$undefined","textColor":"$undefined","link":"https://vca.chat","github":"https://github.com/framersai/voice-chat-assistant","license":"$undefined","technologies":[],"languages":[],"stats":[{"label":"Response Time","value":"< 100ms"},{"label":"Languages Supported","value":"50+"},{"label":"Active Sessions/Day","value":"10k+"},{"label":"Powered By","value":"AgentOS"}],"team":[{"name":"Frame.dev / Framers AI","role":"Core Development","link":"https://github.com/framersai","photo":"$undefined"},{"name":"Manic Agency","role":"Design & Strategy","link":"https://manic.agency","photo":"$undefined"}],"testimonials":[{"quote":"VCA changed how I think about coding. I describe what I want, and it just happens. It's like having a senior developer who never gets tired.","author":"Sarah Chen","role":"Full Stack Developer"},{"quote":"The context awareness is unreal. It remembers our entire conversation and understands my codebase better than I do sometimes.","author":"Marcus Rodriguez","role":"Tech Lead at Scale-up"}]}],"title":"// Related Projects //"}],["$","section",null,{"className":"post-comments","aria-labelledby":"comments-heading","children":[["$","h2",null,{"id":"comments-heading","className":"comments-title","children":"Join the Discussion"}],["$","$L4a",null,{"postTitle":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color","postUrl":"/blog/tutorials/building-magiclogger-and-magic","postIdentifier":"blog-tutorials-building-magiclogger-and-magic","className":"mb-8"}],["$","div",null,{"className":"mt-8","children":[["$","div",null,{"className":"giscus-header","children":[["$","h3",null,{"className":"giscus-title","children":"Comments with GitHub"}],["$","div",null,{"className":"giscus-divider"}]]}],["$","$L4b",null,{}]]}]]}],["$","section",null,{"className":"post-newsletter-signup mt-16","children":["$","$L4c",null,{"variant":"blog","background":"accent"}]}]]}]}]," "]}]," "]}]]}]
1f:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes"}],["$","meta","1",{"name":"theme-color","media":"(prefers-color-scheme: light)","content":"#FBF6EF"}],["$","meta","2",{"name":"theme-color","media":"(prefers-color-scheme: dark)","content":"#22182B"}],["$","meta","3",{"charSet":"utf-8"}],["$","title","4",{"children":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color | Manic Agency - Metaverses Intersection"}],["$","meta","5",{"name":"description","content":"One developer's journey into building a feature-rich colorful logging library and why."}],["$","meta","6",{"name":"author","content":"Johnny Dunn"}],["$","meta","7",{"name":"keywords","content":"typescript,open-source,library,logging"}],["$","meta","8",{"name":"creator","content":"Manic Inc"}],["$","meta","9",{"name":"publisher","content":"Manic Inc"}],["$","link","10",{"rel":"canonical","href":"https://manic.agency/blog/tutorials/building-magiclogger-and-magic"}],["$","meta","11",{"name":"format-detection","content":"telephone=no, address=no, email=no"}],["$","meta","12",{"property":"og:title","content":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color | Manic Agency - Metaverses Intersection"}],["$","meta","13",{"property":"og:description","content":"One developer's journey into building a feature-rich colorful logging library and why."}],["$","meta","14",{"property":"og:image","content":"https://manic.agency//assets/blog/tutorials/building-magiclogger/magiclogger-primary-no-subtitle-transparent-4x.png"}],["$","meta","15",{"property":"og:image:alt","content":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color"}],["$","meta","16",{"property":"og:type","content":"article"}],["$","meta","17",{"property":"article:published_time","content":"2025-10-15T00:00:00.000Z"}],["$","meta","18",{"property":"article:modified_time","content":"2025-11-10T17:22:56.000Z"}],["$","meta","19",{"property":"article:author","content":"Johnny Dunn"}],["$","meta","20",{"property":"article:tag","content":"typescript"}],["$","meta","21",{"property":"article:tag","content":"open-source"}],["$","meta","22",{"property":"article:tag","content":"library"}],["$","meta","23",{"property":"article:tag","content":"logging"}],["$","meta","24",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","25",{"name":"twitter:title","content":"Building MagicLogger and MAGIC: A Universal Logging Standard for Color | Manic Agency - Metaverses Intersection"}],["$","meta","26",{"name":"twitter:description","content":"One developer's journey into building a feature-rich colorful logging library and why."}],["$","meta","27",{"name":"twitter:image","content":"https://manic.agency//assets/blog/tutorials/building-magiclogger/magiclogger-primary-no-subtitle-transparent-4x.png"}],["$","link","28",{"rel":"shortcut icon","href":"/favicon-16x16.png"}],["$","link","29",{"rel":"icon","href":"/favicon.ico"}],["$","link","30",{"rel":"apple-touch-icon","href":"/apple-touch-icon.png"}],["$","meta","31",{"name":"next-size-adjust"}]]
1:null
